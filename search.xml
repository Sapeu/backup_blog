<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git 钩子</title>
    <url>/2018/09/20/Git%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<p>原地址在这里：<a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">自定义 - Git-Git - 钩子</a></p>
<blockquote class="blockquote-center"><h1 id="Git钩子"><a href="#Git钩子" class="headerlink" title="Git钩子"></a> Git 钩子</h1><p>Git 能在特定的重要动作发生时触发自定义脚本。 有两组这样的钩子：客户端的和服务器端的。 客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作</p>
</blockquote>
<a id="more"></a>
<h1 id="Git钩子在哪"><a href="#Git钩子在哪" class="headerlink" title="Git钩子在哪?"></a>Git 钩子在哪？</h1><p>钩子都被存储在 Git 目录下的 hooks 子目录中。 也即绝大部分项目中的 .git/hooks 。 当你用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还透露了被触发时所传入的参数。 所有的示例都是 shell 脚本，其中一些还混杂了 Perl 代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用 Ruby 或 Python，或其它语言编写它们。 这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。</p>
<p>把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。 这样一来，它就能被 Git 调用</p>
<h1 id="客户端钩子"><a href="#客户端钩子" class="headerlink" title="客户端钩子"></a>客户端钩子</h1><p>提交工作流钩子、电子邮件工作流钩子和其它钩子</p>
<h2 id="pre-commit"><a href="#pre-commit" class="headerlink" title="pre-commit"></a>pre-commit</h2><p>钩子在键入提交信息前运行。 它用于检查即将提交的快照，例如，检查是否有所遗漏，确保测试运行，以及核查代码。 如果该钩子以非零值退出，Git 将放弃此次提交，不过你可以用 git commit –no-verify 来绕过这个环节。 你可以利用该钩子，来检查代码风格是否一致（运行类似 lint 的程序）、尾随空白字符是否存在（自带的钩子就是这么做的），或新方法的文档是否适当。</p>
<h2 id="prepare-commit-msg"><a href="#prepare-commit-msg" class="headerlink" title="prepare-commit-msg"></a>prepare-commit-msg</h2><p>prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 它允许你编辑提交者所看到的默认信息。 该钩子接收一些选项：存有当前提交信息的文件的路径、提交类型和修补提交的提交的 SHA-1 校验。 它对一般的提交来说并没有什么用；然而对那些会自动产生默认信息的提交，如提交信息模板、合并提交、压缩提交和修订提交等非常实用。 你可以结合提交模板来使用它，动态地插入信息。</p>
<h2 id="commit-msg"><a href="#commit-msg" class="headerlink" title="commit-msg"></a>commit-msg</h2><p>commit-msg 钩子接收一个参数，此参数即上文提到的，存有当前提交信息的临时文件的路径。 如果该钩子脚本以非零值退出，Git 将放弃提交，因此，可以用来在提交通过前验证项目状态或提交信息。 在本章的最后一节，我们将展示如何使用该钩子来核对提交信息是否遵循指定的模板。</p>
<h2 id="post-commit"><a href="#post-commit" class="headerlink" title="post-commit"></a>post-commit</h2><p>post-commit 钩子在整个提交过程完成后运行。 它不接收任何参数，但你可以很容易地通过运行 git log -1 HEAD 来获得最后一次的提交信息。 该钩子一般用于通知之类的事情</p>
<h2 id="电子邮件工作流钩子"><a href="#电子邮件工作流钩子" class="headerlink" title="电子邮件工作流钩子"></a>电子邮件工作流钩子</h2><p>你可以给电子邮件工作流设置三个客户端钩子。 它们都是由 git am 命令调用的，因此如果你没有在你的工作流中用到这个命令，可以跳到下一节。 如果你需要通过电子邮件接收由 git format-patch 产生的补丁，这些钩子也许用得上。</p>
<h3 id="applypatch-msg"><a href="#applypatch-msg" class="headerlink" title="applypatch-msg"></a>applypatch-msg</h3><p>第一个运行的钩子是 applypatch-msg 。 它接收单个参数：包含请求合并信息的临时文件的名字。 如果脚本返回非零值，Git 将放弃该补丁。 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。</p>
<h3 id="pre-applypatch"><a href="#pre-applypatch" class="headerlink" title="pre-applypatch"></a>pre-applypatch</h3><p>下一个在 git am 运行期间被调用的是 pre-applypatch 。 有些难以理解的是，它正好运行于应用补丁 之后，产生提交之前，所以你可以用它在提交前检查快照。 你可以用这个脚本运行测试或检查工作区。 如果有什么遗漏，或测试未能通过，脚本会以非零值退出，中断 git am 的运行，这样补丁就不会被提交。</p>
<h3 id="post-applypatch"><a href="#post-applypatch" class="headerlink" title="post-applypatch"></a>post-applypatch</h3><p>post-applypatch 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。 你可以用它把结果通知给一个小组或所拉取的补丁的作者。 但你没办法用它停止打补丁的过程</p>
<h1 id="服务器端钩子"><a href="#服务器端钩子" class="headerlink" title="服务器端钩子"></a>服务器端钩子</h1><p>除了客户端钩子，作为系统管理员，你还可以使用若干服务器端的钩子对项目强制执行各种类型的策略。 这些钩子脚本在推送到服务器之前和之后运行。 推送到服务器前运行的钩子可以在任何时候以非零值退出，拒绝推送并给客户端返回错误消息，还可以依你所想设置足够复杂的推送策略。</p>
<h2 id="pre-receive"><a href="#pre-receive" class="headerlink" title="pre-receive"></a>pre-receive</h2><p>处理来自客户端的推送操作时，最先被调用的脚本是 pre-receive。 它从标准输入获取一系列被推送的引用。如果它以非零值退出，所有的推送内容都不会被接受。 你可以用这个钩子阻止对引用进行非快进（non-fast-forward）的更新，或者对该推送所修改的所有引用和文件进行访问控制。</p>
<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>update 脚本和 pre-receive 脚本十分类似，不同之处在于它会为每一个准备更新的分支各运行一次。 假如推送者同时向多个分支推送内容，pre-receive 只运行一次，相比之下 update 则会为每一个被推送的分支各运行一次。 它不会从标准输入读取内容，而是接受三个参数：引用的名字（分支），推送前的引用指向的内容的 SHA-1 值，以及用户准备推送的内容的 SHA-1 值。 如果 update 脚本以非零值退出，只有相应的那一个引用会被拒绝；其余的依然会被更新。</p>
<h2 id="post-receive"><a href="#post-receive" class="headerlink" title="post-receive"></a>post-receive</h2><p>post-receive 挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 它接受与 pre-receive 相同的标准输入数据。 它的用途包括给某个邮件列表发信，通知持续集成（continous integration）的服务器，或者更新问题追踪系统（ticket-tracking system） —— 甚至可以通过分析提交信息来决定某个问题（ticket）是否应该被开启，修改或者关闭。 该脚本无法终止推送进程，不过客户端在它结束运行之前将保持连接状态，所以如果你想做其他操作需谨慎使用它，因为它将耗费你很长的一段时间</p>
<hr>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>钩子</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab+Jenkins+K8S (生产环境可 CI/CD 模拟)</title>
    <url>/2020/07/11/GitLab-Jenkins-K8S-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%8F%AFCI-CD%E6%A8%A1%E6%8B%9F/</url>
    <content><![CDATA[<p>该文档复制自 <a href="https://www.feiyiblog.com/2020/05/11/Docker-k8s-GitLab-Jenkins-%E7%94%9F%E6%88%90%E7%8E%AF%E5%A2%83%E5%8F%AFCI-CD%E6%A8%A1%E6%8B%9F/" target="_blank" rel="noopener">Docker+k8s+GitLab+Jenkins (生产环境可 CI/CD 模拟)</a></p>
<p>这个环境仅做参考</p>
<blockquote class="blockquote-center"><p>通过 Docker+k8s 来部署 web 集群，GitLab+Jenkins 实现代码自动化部署，在 Jenkins 中通过构建脚本，实现 k8s 对容器 web 集群代码自动更新</p>
</blockquote>
<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><table>
<thead>
<tr>
<th style="text-align:left">ip</th>
<th style="text-align:left"> 服务</th>
<th style="text-align:left">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"> 192.168.1.1</td>
<td style="text-align:left">GitLab</td>
<td style="text-align:left"> 内存 4G，双核 CPU（CentOS7.8）</td>
</tr>
<tr>
<td style="text-align:left">192.168.1.4</td>
<td style="text-align:left">Jenkins</td>
<td style="text-align:left"> 内核 2G，双核 CPU（CentOS7.8）</td>
</tr>
<tr>
<td style="text-align:left">192.168.1.11</td>
<td style="text-align:left">Docker+k8s-master</td>
<td style="text-align:left"> 内核 2G，双核 CPU（CentOS7.8）</td>
</tr>
<tr>
<td style="text-align:left">192.168.1.12</td>
<td style="text-align:left">Docker+k8s-node1</td>
<td style="text-align:left"> 内核 2G，双核 CPU（CentOS7.8）</td>
</tr>
<tr>
<td style="text-align:left">192.168.1.13</td>
<td style="text-align:left">Docker+k8s-node2</td>
<td style="text-align:left"> 内核 2G，双核 CPU（CentOS7.8）</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<h1 id="部署目的"><a href="#部署目的" class="headerlink" title="部署目的"></a>部署目的</h1><p>在开发进行代码的更新后，上传到 GitLab，Jenkins 根据 webhook 发现代码的更新后，进行代码构建和 k8s 中的自动部署，展现到 web 界面中</p>
<h1 id="搭建GitLab"><a href="#搭建GitLab" class="headerlink" title="搭建GitLab"></a>搭建 GitLab</h1><p>参考文档 <a href="https://www.feiyiblog.com/2020/03/06/Git版本控制/" target="_blank" rel="noopener">Git 搭建</a>和 <a href="https://www.feiyiblog.com/2020/03/07/GitLab在线代码仓库托管/" target="_blank" rel="noopener">GitLab 搭建</a></p>
<p>除了程序是通过 yum 安装的没有什么不同</p>
<h2 id="192-168-1-1"><a href="#192-168-1-1" class="headerlink" title="192.168.1.1"></a>192.168.1.1</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># hostnamectl set-hostname gitlab</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash</span></span><br><span class="line">[root@gitlab ~]<span class="comment"># vim /etc/hosts</span></span><br><span class="line">192.168.1.1 gitlab</span><br><span class="line">192.168.1.4 jenkins</span><br></pre></td></tr></tbody></table></figure>
<p>开启路由转发</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># echo "net.ipv4.ip_forward = 1" &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line">[root@gitlab ~]<span class="comment"># sysctl -p</span></span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></tbody></table></figure>
<p>安装 Git</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># yum -y install git</span></span><br></pre></td></tr></tbody></table></figure>
<p>配置 GitLab 的 repo 源</p>
<p>使用清华大学的 repo 源</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># cat &lt;&lt;EOF&gt; /etc/yum.repos.d/gitlab-ce.repo</span></span><br><span class="line">[gitlab-ce]</span><br><span class="line">name=Gitlab CE Repository</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/</span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">EOF</span><br></pre></td></tr></tbody></table></figure>
<p>安装 GitLab</p>
<p>使用 yum 安装的最新版本发现对密钥问题还有点不稳定</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># yum -y install gitlab-ce</span></span><br></pre></td></tr></tbody></table></figure>
<p>将 SELinux 设置为禁用，可解决设置 gitlab 公钥后不生效，而且还需要输入账号密码（这个问题我找了十多个小时😓）</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@gitlab ~]<span class="comment"># sed -i 's/^SELINUX=enforcing$/SELINUX=disabled/' /etc/selinux/config</span></span><br></pre></td></tr></tbody></table></figure>
<p>生产环境中需要修改访问 GitLab 的域名或者 ip</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/gitlab/gitlab.rb</span></span><br><span class="line"><span class="comment"># 将external_url 'http://gitlab.example.com'</span></span><br><span class="line"><span class="comment"># 修改为external_url 'http://192.168.1.1'，本机域名或者ip</span></span><br></pre></td></tr></tbody></table></figure>
<p>初始化 GitLab</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># gitlab-ctl reconfigure   # 第一次需要很长时间</span></span><br></pre></td></tr></tbody></table></figure>
<p>启动 GitLab</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># gitlab-ctl start</span></span><br></pre></td></tr></tbody></table></figure>
<p>放行端口</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@gitlab ~]<span class="comment"># firewall-cmd --permanent --add-service=http</span></span><br><span class="line">success</span><br><span class="line">[root@gitlab ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br></pre></td></tr></tbody></table></figure>
<p>登陆到 Web 管理界面设置的登录密码</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.1.1</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://www.feiyiblog.com/uploads/set_password.png" alt="GitLab"></p>
<p>默认用户为 root</p>
<p><img src="https://www.feiyiblog.com/uploads/first_login.png" alt="GitLab"></p>
<p>登录成功</p>
<p><img src="https://www.feiyiblog.com/uploads/gitlab_login.png" alt="img"></p>
<h1 id="搭建Jenkins"><a href="#搭建Jenkins" class="headerlink" title="搭建Jenkins"></a>搭建 Jenkins</h1><p>参考文档 <a href="https://www.feiyiblog.com/2020/03/10/Jenkins代码自动化/" target="_blank" rel="noopener">Jenkins 搭建</a></p>
<p>除了程序是通过 yum 安装的没有什么不同</p>
<h2 id="192-168-1-4"><a href="#192-168-1-4" class="headerlink" title="192.168.1.4"></a>192.168.1.4</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># hostnamectl set-hostname jenkins</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># vim /etc/hosts</span></span><br><span class="line">192.168.1.1 gitlab</span><br><span class="line">192.168.1.4 jenkins</span><br><span class="line">192.168.1.11 k8s-master</span><br><span class="line">192.168.1.12 k8s-node1</span><br><span class="line">192.168.1.13 k8s-node2</span><br></pre></td></tr></tbody></table></figure>
<p>准备 Java 环境</p>
<p>使用 1.8 的 Java 环境</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># yum -y install java-1.8.0-openjdk*</span></span><br></pre></td></tr></tbody></table></figure>
<p>编写 Jenkins 的 repo 源</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># cat &lt;&lt;EOF&gt; /etc/yum.repos.d/jenkins.repo</span></span><br><span class="line">[jenkins]</span><br><span class="line">name=Jenkins-stable</span><br><span class="line">baseurl=https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/</span><br><span class="line">gpgcheck=1</span><br><span class="line">EOF</span><br><span class="line"><span class="comment"># 导入rpm密钥</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># rpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key</span></span><br></pre></td></tr></tbody></table></figure>
<p>安装 Jenkins</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># yum -y install https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/jenkins-2.235.1-1.1.noarch.rpm</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># yum -y install git</span></span><br></pre></td></tr></tbody></table></figure>
<p>安装加速神奇，Jenkins 默认使用 google 来搜索插件的下载，而且插件也在国外网站，这里将 updates 目录中的 <code>default.json</code> 内的 url 换为百度（搜索引擎）和清华（下载插件地址），<strong>前提必须出现过以上界面才会有 updates 目录</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># sed -i 's/http:\/\/www.google.com/https:\/\/www.baidu.com/g' /var/lib/jenkins/updates/default.json</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># sed -i 's/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g' /var/lib/jenkins/updates/default.json</span></span><br></pre></td></tr></tbody></table></figure>
<p>启动 Jenkins，并放行 8080 端口</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># systemctl start jenkins</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># systemctl enable jenkins</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># firewall-cmd --permanent --add-port=8080/tcp</span></span><br><span class="line">success</span><br><span class="line">[root@jenkins ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">success</span><br></pre></td></tr></tbody></table></figure>
<p>进入 Jenkins 的 web 安装界</p>
<p>访问 <code>http://192.168.1.4:8080</code></p>
<p><img src="https://www.feiyiblog.com/uploads/wait_jiemian.png" alt="Jenkins"></p>
<p>在 Linux 本地查看管理员密码</p>
<p><img src="https://www.feiyiblog.com/uploads/lock_jenkins.png" alt="Jenkins"></p>
<p>输入密码后，如果出现此界面</p>
<p><img src="https://www.feiyiblog.com/uploads/shaowait.png" alt="Jenkins"></p>
<p>如果出现以下</p>
<p><img src="https://www.feiyiblog.com/uploads/lixian.png" alt="Jenkins"></p>
<p>解决方法如下：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">第一步 打开插件管理的高级设置页面</span><br><span class="line">http://192.168.1.4:8080/pluginManager/advanced</span><br><span class="line"></span><br><span class="line">第二步 修改更新站点地址</span><br><span class="line">将https改为http  如果不行 可以用清华的加速站点 如下</span><br><span class="line">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</span><br></pre></td></tr></tbody></table></figure>
<p>安装推荐插件</p>
<p><img src="https://www.feiyiblog.com/uploads/install_chajian.png" alt="Jenkins"></p>
<p><img src="https://www.feiyiblog.com/uploads/wait_install.png" alt="Jenkins"></p>
<p>然后重启服务，并重新访问 Jenkins 的 web 界面</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># systemctl restart jenkins</span></span><br></pre></td></tr></tbody></table></figure>
<p>安装完成后，创建管理用户</p>
<p><img src="https://www.feiyiblog.com/uploads/create_jenkins_user.png" alt="Jenkins"></p>
<p><img src="https://www.feiyiblog.com/uploads/shili_config.png" alt="Jenkins"></p>
<p><img src="https://www.feiyiblog.com/uploads/jenkins_install_success.png" alt="Jenkins"></p>
<p>在插件管理中安装三个关于 GitLab 的插件，用于持续集成</p>
<blockquote>
<p>Gitlab Authentication</p>
<p>Gitlab</p>
<p>Gitlab Hook</p>
</blockquote>
<p>选择安装后自动重启 Jenkins</p>
<h1 id="搭建Kubernetes集群"><a href="#搭建Kubernetes集群" class="headerlink" title="搭建Kubernetes集群"></a>搭建 Kubernetes 集群</h1><p>参考本站文档 <a href="https://www.feiyiblog.com/2020/03/23/安装Docker——镜像加速/" target="_blank" rel="noopener">Docker 安装</a>和 <a href="https://www.feiyiblog.com/2020/04/17/kubernetes安装及集群搭建/" target="_blank" rel="noopener">Kubernetes 集群搭建</a></p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>按照运行环境中的系统版本和硬件要求</p>
<p>这里使用的现成的 Docker 环境，没有的可以参考以上链接部署</p>
<h3 id="更改主机名"><a href="#更改主机名" class="headerlink" title="更改主机名"></a>更改主机名</h3><p><strong>192.168.1.11</strong></p>
<p>更改主机名，并设置对其他两台节点的免密登录</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># hostnamectl set-hostname k8s-master</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># vim /etc/hosts</span></span><br><span class="line">192.168.1.11 k8s-master</span><br><span class="line">192.168.1.12 k8s-node1</span><br><span class="line">192.168.1.13 k8s-node2</span><br><span class="line">[root@k8s-master ~]<span class="comment"># ssh-keygen</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">'/root/.ssh'</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:y0cMv9gJDShPYbfH/+WUbwtLJivwGTNv4EVT6TpxXHQ root@k8s-master</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|      o .     o.E|</span></span><br><span class="line"><span class="string">|     . + o   o ..|</span></span><br><span class="line"><span class="string">|    . o + o + .  |</span></span><br><span class="line"><span class="string">|     +   B = +  .|</span></span><br><span class="line"><span class="string">|      . S * *  .o|</span></span><br><span class="line"><span class="string">|       o @ * . +.|</span></span><br><span class="line"><span class="string">|        B &amp;..+. +|</span></span><br><span class="line"><span class="string">|         * o= o..|</span></span><br><span class="line"><span class="string">|          o. . . |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br><span class="line"><span class="string">[root@k8s-master ~]# ssh-copy-id -i root@k8s-node1</span></span><br><span class="line"><span class="string">[root@k8s-master ~]# ssh-copy-id -i root@k8s-node2</span></span><br></pre></td></tr></tbody></table></figure>
<p>将 hosts 文件传输到其他两台节点</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># scp /etc/hosts root@k8s-node1:/etc</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># scp /etc/hosts root@k8s-node2:/etc</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>192.168.1.12</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># hostnamectl set-hostname k8s-node1</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash</span></span><br><span class="line">[root@k8s-node1 ~]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>192.168.1.13</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># hostnamectl set-hostname k8s-node2</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bash</span></span><br><span class="line">[root@k8s-node2 ~]<span class="comment">#</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="关闭沙盒"><a href="#关闭沙盒" class="headerlink" title="关闭沙盒"></a>关闭沙盒</h3><p><strong>k8s-master/node1/node2</strong></p>
<p>将 SELinux 设置为禁用（也可以设置为 permissive 模式）</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># sed -i 's/^SELINUX=enforcing$/SELINUX=disabled/' /etc/selinux/config</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="开放所需端口"><a href="#开放所需端口" class="headerlink" title="开放所需端口"></a>开放所需端口</h3><p>防火墙放行端口，因为比较多，省事可以直接 <code>systemctl stop firewalld</code></p>
<p><strong>master 节点</strong></p>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>作用</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td> TCP</td>
<td> 入站</td>
<td> 6443*</td>
<td>Kubernetes API 服务器</td>
<td>所有组件</td>
</tr>
<tr>
<td> TCP</td>
<td> 入站</td>
<td> 2379-2380</td>
<td>etcd server client API</td>
<td>kube-apiserver, etcd</td>
</tr>
<tr>
<td>TCP</td>
<td> 入站</td>
<td> 10250</td>
<td>Kubelet API</td>
<td>kubelet 自身、控制平面组件</td>
</tr>
<tr>
<td> TCP</td>
<td> 入站</td>
<td> 10251</td>
<td>kube-scheduler</td>
<td>kube-scheduler 自身</td>
</tr>
<tr>
<td> TCP</td>
<td> 入站</td>
<td> 10252</td>
<td>kube-controller-manager</td>
<td>kube-controller-manager 自身 </td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --permanent --add-port=6443/tcp</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --permanent --add-port=64430-64439/tcp</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --permanent --add-port=2379-2380/tcp</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --permanent --add-port=10250-10252/tcp</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>所有 node 工作节点</strong></p>
<table>
<thead>
<tr>
<th>协议</th>
<th>方向</th>
<th>端口范围</th>
<th>作用</th>
<th>使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td> TCP</td>
<td> 入站</td>
<td> 10250</td>
<td>Kubelet API</td>
<td>kubelet 自身、控制平面组件</td>
</tr>
<tr>
<td> TCP</td>
<td> 入站</td>
<td> 30000-32767</td>
<td>NodePort 服务 **</td>
<td> 所有组件 </td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]<span class="comment"># firewall-cmd --permanent --add-port=10250/tcp</span></span><br><span class="line">[root@k8s-node1 ~]<span class="comment"># firewall-cmd --permanent --add-port=30000-32767/tcp</span></span><br><span class="line">[root@k8s-node1 ~]<span class="comment"># firewall-cmd --reload</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="验证节点UUID"><a href="#验证节点UUID" class="headerlink" title="验证节点UUID"></a>验证节点 UUID</h3><p>查看每个服务器的 uuid，必须不能重复</p>
<p><strong>k8s-master</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># cat /sys/class/dmi/id/product_uuid</span></span><br><span class="line">E2B74D56-23A9-4E8B-620C-555387355616</span><br></pre></td></tr></tbody></table></figure>
<h3 id="关闭swap分区"><a href="#关闭swap分区" class="headerlink" title="关闭swap分区"></a>关闭 swap 分区</h3><p>三台节点同样的操作</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># swapoff -a</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># vim /etc/fstab</span></span><br><span class="line"><span class="comment"># 将分区类型为swap的一行注释掉</span></span><br><span class="line">/dev/mapper/centos-swap swap</span><br><span class="line"><span class="comment"># 还是需要调整内核参数</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># 末尾添加</span></span><br><span class="line">vm.swappiness = 0</span><br><span class="line">[root@k8s-master ~]<span class="comment"># sysctl -p</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="设置内核参数"><a href="#设置内核参数" class="headerlink" title="设置内核参数"></a>设置内核参数</h3><p>调整 iptables 桥接流量，依赖于 docker 的启动，所以需要确保 docker 已经启动</p>
<p><strong>k8s-master</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># vim /etc/sysctl.conf</span></span><br><span class="line"><span class="comment"># 末尾添加</span></span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">[root@k8s-master ~]<span class="comment"># sysctl -p</span></span><br><span class="line"><span class="comment"># 为确保桥接流量不报错，执行以下命令</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># modprobe ip_vs_rr</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># modprobe br_netfilter</span></span><br><span class="line"><span class="comment"># 将修改好的文件传输到node1和node2</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># scp /etc/sysctl.conf root@k8s-node1:/etc</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># scp /etc/sysctl.conf root@k8s-node2:/etc</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>k8s-node1</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]<span class="comment"># sysctl -p</span></span><br><span class="line">[root@k8s-node1 ~]<span class="comment"># modprobe ip_vs_rr</span></span><br><span class="line">[root@k8s-node1 ~]<span class="comment"># modprobe br_netfilter</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>k8s-node2</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-node2 ~]<span class="comment"># sysctl -p</span></span><br><span class="line">[root@k8s-node2 ~]<span class="comment"># modprobe ip_vs_rr</span></span><br><span class="line">[root@k8s-node2 ~]<span class="comment"># modprobe br_netfilter</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装Kubernetes"><a href="#安装Kubernetes" class="headerlink" title="安装Kubernetes"></a>安装 Kubernetes</h2><h3 id="编写yum源"><a href="#编写yum源" class="headerlink" title="编写yum源"></a>编写 yum 源</h3><p><strong>k8s-master</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># vim /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></tbody></table></figure>
<p>将 yum 源传给每台节点</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># scp /etc/yum.repos.d/kubernetes.repo root@k8s-node1:/etc/yum.repos.d/</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># scp /etc/yum.repos.d/kubernetes.repo root@k8s-node2:/etc/yum.repos.d/</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="安装k8s"><a href="#安装k8s" class="headerlink" title="安装k8s"></a>安装 k8s</h3><p><strong>k8s-master/node1/node2</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># yum -y install kubelet kubeadm kubectl</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果有的节点在 yum 安装时，报错 404，尝试执行 <code>rm -rf /var/cache/yum/*</code> 后，重新安装</p>
<p>查看 k8s 版本</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubeadm version</span></span><br><span class="line">kubeadm version: &amp;version.Info{Major:<span class="string">"1"</span>, Minor:<span class="string">"18"</span>, GitVersion:<span class="string">"v1.18.2"</span>,</span><br><span class="line">GitCommit:<span class="string">"52c56ce7a8272c798dbc29846288d7cd9fbae032"</span>, GitTreeState:<span class="string">"clean"</span>,</span><br><span class="line">BuildDate:<span class="string">"2020-04-16T11:54:15Z"</span>, GoVersion:<span class="string">"go1.13.9"</span>, Compiler:<span class="string">"gc"</span>,</span><br><span class="line">Platform:<span class="string">"linux/amd64"</span>}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>k8s-master</strong></p>
<p>安装 kubernetes 的 tab 快捷键，只需要在 master 安装即可</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># yum -y install bash-completion</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bashrc &amp;&amp; bash</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="启动k8s"><a href="#启动k8s" class="headerlink" title="启动k8s"></a>启动 k8s</h3><p><strong>k8s-master/node1/node2</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># systemctl enable --now kubelet</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Kubernetes集群搭建"><a href="#Kubernetes集群搭建" class="headerlink" title="Kubernetes集群搭建"></a>Kubernetes 集群搭建</h2><p><strong>k8s-master</strong></p>
<p>初始化集群，完成后获取 token 值</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubeadm init --apiserver-advertise-address 192.168.1.11 \</span></span><br><span class="line">--image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">--kubernetes-version v1.18.2 --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></tbody></table></figure>
<p>使用管理用户（非 root）执行以下操作</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># mkdir -p $HOME/.kube</span></span><br><span class="line">[admin@k8s-master ~]$ sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">[admin@k8s-master ~]$ sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></tbody></table></figure>
<p>使用 root 用户执行以下操作</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bashrc &amp;&amp; source ~/.bashrc</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="部署集群网络"><a href="#部署集群网络" class="headerlink" title="部署集群网络"></a>部署集群网络</h3><p>下载 flannel 网络配置文件，有时候会下载失败，前往 <a href="https://github.com/coreos/flannel/blob/master/Documentation/kube-flannel.yml" target="_blank" rel="noopener">coreos/flannel 项目</a>手动将内容复制到 <code>kube-flannel.yml</code> 文件中</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># curl -LO https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line"><span class="comment"># 将quay.io改为国内quay-mirror.qiniu.com</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># sed -i s/quay.io/quay-mirror.qiniu.com/g kube-flannel.yml</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后执行以下操作</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl apply -f kube-flannel.yml</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="节点加入集群"><a href="#节点加入集群" class="headerlink" title="节点加入集群"></a>节点加入集群</h3><p>如果之前生成的 token 值忘了，查看 <code>kubeadm token list</code>，还能往上翻看到 token 值就跳过这步</p>
<p><strong>k8s-master</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubeadm token list</span></span><br><span class="line">TOKEN                     TTL         EXPIRES                     USAGES</span><br><span class="line">jppmrh.1hovp0cyt4xu2w1l   23h         2020-05-11T02:05:53+08:00   authentication,signing</span><br><span class="line"><span class="comment"># 将它删除重新生成</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubeadm token delete jppmrh.1hovp0cyt4xu2w1l</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果找不到了，重新生成</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubeadm token create --print-join-command</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>k8s-node1/node2</strong></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-node1 ~]<span class="comment"># kubeadm join 192.168.1.11:6443 --token bdsiop.8ptt7ky6t088xyl8 \</span></span><br><span class="line">    --discovery-token-ca-cert-hash sha256:1b61fd611bd12f46c7c065995f304ad232f2a598cb99127ccc547612ea57eac0</span><br></pre></td></tr></tbody></table></figure>
<p>输出信息为以下则成功</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Run 'kubectl get nodes' on the control-plane to see this node join the cluster.</span><br></pre></td></tr></tbody></table></figure>
<h3 id="验证集群节点"><a href="#验证集群节点" class="headerlink" title="验证集群节点"></a>验证集群节点</h3><p><strong>k8s-master</strong></p>
<p>等待一段时间，直至状态全部为 Ready</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get nodes</span></span><br><span class="line">NAME         STATUS   ROLES    AGE     VERSION</span><br><span class="line">k8s-master   Ready    master   10m     v1.18.2</span><br><span class="line">k8s-node1    Ready    &lt;none&gt;   3m56s   v1.18.2</span><br><span class="line">k8s-node2    Ready    &lt;none&gt;   3m56s   v1.18.2</span><br></pre></td></tr></tbody></table></figure>
<p>集群搭建成功</p>
<h1 id="运行Docker私库—Registry"><a href="#运行Docker私库—Registry" class="headerlink" title="运行Docker私库—Registry"></a>运行 Docker 私库 —Registry</h1><p>为了在环境中更好的管理 Docker 镜像，决定使用 Registry 来运行一个容器，用来存放 docker 镜像，也减少了镜像存储在国外源或者国内源的传输效率，当然也能使用 harbor 私库代替 Registry</p>
<p><strong>k8s-master</strong></p>
<p>创建镜像存放目录</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># mkdir -p /data/docker/registry</span></span><br></pre></td></tr></tbody></table></figure>
<p>下载镜像</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># docker pull registry:2</span></span><br></pre></td></tr></tbody></table></figure>
<p>运行私库容器</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># docker run -itd -p 5000:5000 --restart always \</span></span><br><span class="line">--volume /data/docker/registry/:/var/lib/registry registry:2</span><br></pre></td></tr></tbody></table></figure>
<p>查看端口是否映射成功</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># netstat -anput | grep 5000</span></span><br></pre></td></tr></tbody></table></figure>
<p>检查能否访问到私库</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --permanent --add-port=5000/tcp</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># firewall-cmd --reload</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># curl 192.168.1.11:5000/v2/_catalog</span></span><br><span class="line">{<span class="string">"repositories"</span>:[]}</span><br></pre></td></tr></tbody></table></figure>
<p>设置三台 docker 都能识别私库地址</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># vim /usr/lib/systemd/system/docker.service</span></span><br><span class="line"><span class="comment"># 以ExecStart开头的一行的末尾添加--insecure-registry 192.168.1.11:5000</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># scp /usr/lib/systemd/system/docker.service root@k8s-node1:/usr/lib/systemd/system/</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># scp /usr/lib/systemd/system/docker.service root@k8s-node2:/usr/lib/systemd/system/</span></span><br></pre></td></tr></tbody></table></figure>
<p>全部重启 docker</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># systemctl daemon-reload &amp;&amp; systemctl restart docker</span></span><br></pre></td></tr></tbody></table></figure>
<p>制作一个镜像上传到私库测试</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># wget http://nginx.org/download/nginx-1.11.1.tar.gz</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># vim Dockerfile</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER FeiYi</span><br><span class="line">RUN yum -y install net-tools iproute pcre-devel openssl-devel gcc gcc-c++ make zlib-devel elinks</span><br><span class="line">ADD nginx-1.11.1.tar.gz /usr/src</span><br><span class="line">ENV NGINX_DIR /usr/src/nginx-1.11.1</span><br><span class="line">WORKDIR <span class="variable">$NGINX_DIR</span></span><br><span class="line">RUN ./configure --prefix=/usr/<span class="built_in">local</span>/nginx --user=nginx --group=nginx &amp;&amp; make &amp;&amp; make install</span><br><span class="line">WORKDIR /</span><br><span class="line">RUN useradd nginx</span><br><span class="line">RUN ln -s /usr/<span class="built_in">local</span>/nginx/sbin/nginx /usr/sbin/nginx</span><br><span class="line">EXPOSE 80</span><br><span class="line">CMD [<span class="string">"nginx"</span>, <span class="string">"-g"</span>, <span class="string">"daemon off;"</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>构建镜像</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># docker build -t 192.168.1.11:5000/bin-nginx:latest /root</span></span><br></pre></td></tr></tbody></table></figure>
<p>上传镜像</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># docker push 192.168.1.11:5000/bin-nginx</span></span><br><span class="line">[root@k8s-master ~]<span class="comment"># curl 192.168.1.11:5000/v2/_catalog</span></span><br><span class="line">{<span class="string">"repositories"</span>:[<span class="string">"bin-nginx"</span>]}</span><br></pre></td></tr></tbody></table></figure>
<p>私库成功</p>
<h1 id="使用k8s启动nginx容器"><a href="#使用k8s启动nginx容器" class="headerlink" title="使用k8s启动nginx容器"></a>使用 k8s 启动 nginx 容器</h1><p><strong>k8s-master</strong></p>
<h2 id="编写Deployment的模板文件"><a href="#编写Deployment的模板文件" class="headerlink" title="编写Deployment的模板文件"></a>编写 Deployment 的模板文件</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># vim nginx-deployment.yml</span></span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: 192.168.1.11:5000/bin-nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br></pre></td></tr></tbody></table></figure>
<p>运行模板文件</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># kubectl apply -f nginx-deployment.yml</span></span><br><span class="line">deployment.apps/nginx created</span><br></pre></td></tr></tbody></table></figure>
<p>查看是否运行成功</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># kubectl get pod -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE    IP           NODE</span><br><span class="line">nginx-66fb94d868-h2fkk   1/1     Running   0          2m5s   10.244.2.2   node2</span><br><span class="line">nginx-66fb94d868-zhkf8   1/1     Running   0          2m5s   10.244.1.2   node3</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到容器的 ip，现在只能在运行容器的节点才能够访问到页面内容，如果想让外部主机访问到，需要做一个 service 模板，用来映射端口</p>
<h2 id="编写Service模板"><a href="#编写Service模板" class="headerlink" title="编写Service模板"></a>编写 Service 模板</h2><p>将集群中标签为 app: nginx 的容器的 80 端口映射为服务器的 30001</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># vim nginx-service.yml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx</span><br><span class="line">  labels:</span><br><span class="line">    app: nginx</span><br><span class="line">spec:</span><br><span class="line">  <span class="built_in">type</span>: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 80</span><br><span class="line">    nodePort: 30001</span><br><span class="line">  selector:</span><br><span class="line">    app: nginx</span><br></pre></td></tr></tbody></table></figure>
<p>运行 Service 模板</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@node1 ~]<span class="comment"># kubectl apply -f nginx-service.yml</span></span><br><span class="line">service/nginx created</span><br></pre></td></tr></tbody></table></figure>
<p>访问宿主机的 30001 端口</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.1.12:30001`和`http://192.168.1.13:30001</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_nginx.png" alt="k8s_nginx"></p>
<p>容器部署成功</p>
<h1 id="整合GitLab和Jenkins"><a href="#整合GitLab和Jenkins" class="headerlink" title="整合GitLab和Jenkins"></a>整合 GitLab 和 Jenkins</h1><p><strong>Jenkins</strong></p>
<p>在 Jenkins 生成密钥对</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># ssh-keygen</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):</span><br><span class="line">Created directory <span class="string">'/root/.ssh'</span>.</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:IITvkptc3nJrgxCxA0R0+ExWm5y/PfSIdKaQpD0NhUc root@jenkins</span><br><span class="line">The key<span class="string">'s randomart image is:</span></span><br><span class="line"><span class="string">+---[RSA 2048]----+</span></span><br><span class="line"><span class="string">|++.oo.oE         |</span></span><br><span class="line"><span class="string">|..++..=.         |</span></span><br><span class="line"><span class="string">| .=+.Bo          |</span></span><br><span class="line"><span class="string">|  +o=.=.         |</span></span><br><span class="line"><span class="string">|   * = +S+       |</span></span><br><span class="line"><span class="string">|  + o + O o      |</span></span><br><span class="line"><span class="string">| . B o + + .     |</span></span><br><span class="line"><span class="string">|  + + =   .      |</span></span><br><span class="line"><span class="string">|     +.o         |</span></span><br><span class="line"><span class="string">+----[SHA256]-----+</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>GitLab</strong></p>
<p>登录 GitLab</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.1.1</span><br></pre></td></tr></tbody></table></figure>
<p>创建项目仓库</p>
<p><img src="https://jf.ssjinyao.com/uploads/admin_create_project.png" alt="gitlab"></p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_gitlab.png" alt="k8s_gitlab"></p>
<p>在 GitLab 中添加 Jenkins 的公钥值</p>
<p><img src="https://jf.ssjinyao.com/uploads/add_id_rsa_pub.png" alt="gitlab"></p>
<p>复制 Jenkins 服务器的公钥到下图位置，查看公钥 <code>cat .ssh/id_rsa.pub</code></p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_gitlab1.png" alt="k8s_gitlab1"></p>
<p>在 GitLab 的项目仓库，创建一个测试代码文件</p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_gitlab2.png" alt="k8s_gitlab2"></p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_gitlab3.png" alt="k8s_gitlab3"></p>
<p>因为密钥上传的是 Jenkins 的，所以在 Jenkins 上下载查看</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># git clone http://192.168.1.1/root/nginx-test.git</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># cd nginx-test/</span></span><br><span class="line">[root@jenkins nginx-test]<span class="comment"># cat index.html</span></span><br><span class="line">ChaiYanjiang</span><br></pre></td></tr></tbody></table></figure>
<p>成功</p>
<p><strong>Jenkins</strong></p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">http://192.168.1.4:8080/</span><br></pre></td></tr></tbody></table></figure>
<p>创建任务 nginx-test</p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_jenkins.png" alt="k8s_jenkins"></p>
<p>设置源码管理时在 Gitlab 的地址，出现红色说明连接不到，因为 GitLab 已经有了 Jenkins 的公钥，这里只需要填写 Jenkins 的私钥即可</p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_jenkins2.png" alt="k8s_jenkins2"></p>
<p><img src="https://www.feiyiblog.com/uploads/create_con_gitlab.png" alt="Jenkins"></p>
<p>红色报错消失了</p>
<p><img src="https://www.feiyiblog.com/uploads/choose_pingzheng_gitlab.png" alt="Jenkins"></p>
<p>设置构建触发器</p>
<p>当 gitlab 发生代码变化时，开始进行构建任务</p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_jenkins3.png" alt="k8s_jenkins3"></p>
<p>生成一串 token 值，用来对 GitLab 中的项目代码进行操作，所以这个值要放到 GitLab 中，用于验证允许 Jenkins 来拿取代码，稍后会将</p>
<p><img src="https://www.feiyiblog.com/uploads/sheng_token.png" alt="k8s_build"></p>
<p>设置构建的命令（CI/CD）</p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_build.png" alt="k8s_build"></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">backupcode=/data/backupcode/<span class="variable">$JOB_NAME</span>/</span><br><span class="line">mkdir -p <span class="variable">$backupcode</span></span><br><span class="line">chmod 644 <span class="variable">$JENKINS_HOME</span>/workspace/<span class="variable">$JOB_NAME</span>/*</span><br><span class="line">rsync -acP <span class="variable">$JENKINS_HOME</span>/workspace/<span class="variable">$JOB_NAME</span>/* <span class="variable">$backupcode</span></span><br><span class="line"><span class="built_in">echo</span> From 192.168.1.11:5000/bin-nginx &gt; <span class="variable">$JENKINS_HOME</span>/workspace/Dockerfile</span><br><span class="line"><span class="built_in">echo</span> COPY ./nginx-test/* /usr/<span class="built_in">local</span>/nginx/html/ &gt;&gt; <span class="variable">$JENKINS_HOME</span>/workspace/Dockerfile</span><br><span class="line">docker rmi 192.168.1.11:5000/bin-nginx:latest</span><br><span class="line">docker build -t 192.168.1.11:5000/bin-nginx:latest <span class="variable">$JENKINS_HOME</span>/workspace/</span><br><span class="line">docker push 192.168.1.11:5000/bin-nginx:latest</span><br><span class="line">ssh root@k8s-master kubectl delete deployment nginx</span><br><span class="line">ssh root@k8s-master kubectl apply -f nginx-deployment.yml</span><br></pre></td></tr></tbody></table></figure>
<p>保存即可</p>
<p><strong>GitLab</strong></p>
<p>192.168.1.1 中设置 Jenkins 中的 token 值，用来触发 Jenkins 构建</p>
<p>GitLab 默认情况下不允许通过本地网络触发构建，以下这步是为了设置允许本地网络构建，如果不设置允许会在添加 token 时报错</p>
<p><img src="https://www.feiyiblog.com/uploads/admin_settings_integrations.png" alt="GitLab"></p>
<p><img src="https://www.feiyiblog.com/uploads/outbound_requests.png" alt="GitLab"></p>
<p><img src="https://www.feiyiblog.com/uploads/allow_webhooks.png" alt="GitLab"></p>
<p>保存</p>
<p>设置允许之后，就可以设置 GitLab 项目与 Jenkins 的构建触发器连接了</p>
<p><strong>进入项目</strong>中选择设置</p>
<p><img src="https://www.feiyiblog.com/uploads/cd_reops_settings.png" alt="gitlab"></p>
<p>图中的 URL 是在 Jenkins 中的项目路径，这个路径在构建触发器的那里可以看到，复制即可，token 则是刚才在 Jenkins 的管理界面中生成的 token 值，也是同样的位置，然后点击下方 <code>add webhook</code></p>
<p><img src="https://jf.ssjinyao.com/uploads/gitlab_token.png" alt="gitlab_token"></p>
<p>add 成功后，往下翻到如图所示位置可以看添加成功的 URL，然后进行连接测试，出现 200 即成功</p>
<p><img src="https://jf.ssjinyao.com/uploads/gitlab_webhooktest.png" alt="gitlab_webhooktest"></p>
<h1 id="整合Jenkins和Docker"><a href="#整合Jenkins和Docker" class="headerlink" title="整合Jenkins和Docker"></a>整合 Jenkins 和 Docker</h1><p><strong>Jenkins</strong></p>
<p>在 Jenkins 中做对 k8s-master 的免密登录，得先修改 Jenkins 的运行用户，这里我直接用 root 代替，生产环境请参考这里的 <a href="https://www.feiyiblog.com/2020/03/12/GitLab-Jenkins-Tomcat/" target="_blank" rel="noopener">scp 报错部分</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># vim /etc/sysconfig/jenkins</span></span><br><span class="line"> 修改jenkins用户</span><br><span class="line">JENKINS_USER=<span class="string">"jenkins"</span>   <span class="comment"># 修改为root</span></span><br></pre></td></tr></tbody></table></figure>
<p>重启 Jenkins 并传输密钥</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[root@jenkins ~]<span class="comment"># systemctl restart jenkins</span></span><br><span class="line">[root@jenkins ~]<span class="comment"># ssh-copy-id -i root@k8s-master</span></span><br></pre></td></tr></tbody></table></figure>
<p>安装 Docker，参考文档 <a href="https://www.feiyiblog.com/2020/03/23/安装Docker——镜像加速/" target="_blank" rel="noopener">Docker 安装</a>，并设置镜像加速，和指定私库地址</p>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>修改 GitLab 的测试文件测试 Jenkins 的自动化部署是否成功</p>
<p><img src="https://jf.ssjinyao.com/uploads/gitlab_test.png" alt="gitlab_test"></p>
<p>保存后会开始自动构建部署，访问 <code>192.168.1.13:30001</code>，如果是以下则成功，如果构建失败，则检查构建脚本，慢慢排错</p>
<p><img src="https://jf.ssjinyao.com/uploads/k8s_cicd.png" alt="k8s_cicd"></p>
<hr>
]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
        <tag>Jenkins</tag>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>Gogs 无法读取远程仓库（fatal: XX/XX.git does not appear to be a git repository）</title>
    <url>/2018/09/21/Gogs%E6%97%A0%E6%B3%95%E8%AF%BB%E5%8F%96%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%EF%BC%88fatal-XX-XX-git-does-not-appear-to-be-a-git-repository%EF%BC%89/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>错误描述：<code>fatal: 'XX/XX.git' does not appear to be a git repository</code></p>
</blockquote>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>部署完 Gogs 后，在 Web 页面创建好仓库后，本地向远程推送出现<code>无法读取远程仓库</code>的问题，可能原因：<code>~/.ssh/authorized_keys</code> 文件中存在重复的 SSH 密钥，所以<a href="https://gogs.io/docs/intro/troubleshooting#%E5%85%AC%E9%92%A5%E4%BD%BF%E7%94%A8%E5%86%B2%E7%AA%81" target="_blank" rel="noopener">公钥使用冲突</a>了</p>
<a id="more"></a>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>删除 <code>~/.ssh/authorized_keys</code> 文件里除了属于 Gogs 自动添加以外的重复密钥，这样就可以正常了</p>
<h1 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h1><p>但是这样又出现了个新的问题，就是我用 <code>ssh</code> 登不上我的远程服务器了，原来刚刚删除的那个秘钥是 <code>ssh</code> 远程登录密钥，这样可不行的呀</p>
<h1 id="新的方案"><a href="#新的方案" class="headerlink" title="新的方案"></a>新的方案</h1><p>额外再生成一个新的密钥 <code>id_rsa_gogs</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">'邮箱或者其他标识'</span> -f ~/.ssh/id_rsa_gogs</span><br></pre></td></tr></tbody></table></figure>
<p>再在本地新建（如果存在就修改）<code>~/.ssh/config</code> 添加以下内容</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Host gogs</span><br><span class="line">    HostName example.com <span class="comment"># IP地址或者域名</span></span><br><span class="line">    Port 222 <span class="comment"># ssh端口号</span></span><br><span class="line">    User git <span class="comment"># 远程服务器的用户名</span></span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_gogs <span class="comment"># 刚才生成的密钥的路径</span></span><br><span class="line">    IdentitiesOnly Yes <span class="comment"># 只使用这里设置的key</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后就可以使用 <code>gogs</code> 这个别名来代替 <code>user@host:222</code> 了</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 以前仓库地址为</span></span><br><span class="line">user@host:222/repositories-path/xxx.git</span><br><span class="line"><span class="comment"># 改为现在的地址</span></span><br><span class="line">gogs:/repositories-path/xxx.git</span><br></pre></td></tr></tbody></table></figure>
<p>这样就 OK 了，看看<a href="https://discuss.gogs.io/t/how-to-config-ssh-settings/34" target="_blank" rel="noopener">其他方案</a></p>
<hr>
]]></content>
      <categories>
        <category>Gogs</category>
      </categories>
      <tags>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 的安装配置以及部署</title>
    <url>/2018/09/17/Hexo%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Hexo 是一个快速、简洁且高效的博客框架 </p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在本地使用 hexo 框架，需要电脑中已安装 <a href="http://git-scm.com" target="_blank" rel="noopener">Git</a>、<a href="http://nodejs.org" target="_blank" rel="noopener">Node.js</a></p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装 Git</h2><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a></li>
<li>Mac：使用 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew</a> ：<code>brew install git --with-gettext</code></li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<a id="more"></a>
<h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装 Node.js</h2><p>Node.js 有多个版本，建议使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm (Node Version Manager)</a> 来管理 node 的版本。对于 windows 小伙伴来说，建议<a href="https://nodejs.org/zh-cn/download/" target="_blank" rel="noopener">使用 Node.js 安装程序</a>进行安装，喜欢折腾的小伙伴可以试试 <a href="https://github.com/coreybutler/nvm-windows" target="_blank" rel="noopener">nvm-windows</a></p>
<p>安装 Node.js</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">nvm install stable</span><br></pre></td></tr></tbody></table></figure>
<p>使用<a href="http://npm.taobao.org/mirrors/node" target="_blank" rel="noopener">淘宝的 Node.js 镜像</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># nvm 使用镜像安装</span></span><br><span class="line">NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node nvm install stable</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows小伙伴如果使用 nvm-windows，设置镜像</span></span><br><span class="line">nvm node_mirror https://npm.taobao.org/mirrors/node/</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装 Hexo</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>
<p>国内小伙伴建议使用<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝 NPM 镜像</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 安装cnpm</span></span><br><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br><span class="line"><span class="comment"># 使用cnpm安装hexo</span></span><br><span class="line">cnpm install -g hexo-cli</span><br><span class="line"></span><br><span class="line"><span class="comment"># windows小伙伴如果使用 nvm-windows，设置npm镜像</span></span><br><span class="line">nvm npm_mirror https://npm.taobao.org/mirrors/npm/</span><br></pre></td></tr></tbody></table></figure>
<h1 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用 hexo</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># --no-install 是使用初始化后跳过npm install</span></span><br><span class="line">hexo init 项目文件夹 --no-install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入项目目录</span></span><br><span class="line"><span class="built_in">cd</span> 项目文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">cnpm install</span><br></pre></td></tr></tbody></table></figure>
<p>查看 <code>hexo init</code> 更多帮助<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo init -h</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># s 是 server</span></span><br><span class="line"></span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure>
<p>然后会输出以下信息</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop.</span><br></pre></td></tr></tbody></table></figure>
<p>然后在可以本地浏览器打开 <a href="http://localhost:4000，就可以访问启动好的博客啦" target="_blank" rel="noopener">http://localhost:4000，就可以访问启动好的博客啦</a></p>
<p>查看 <code>hexo server</code> 更多帮助，也可参考 <a href="https://hexo.io/zh-cn/docs/server" target="_blank" rel="noopener">Hexo 服务器</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo s -h</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="安装Next主题"><a href="#安装Next主题" class="headerlink" title="安装Next主题"></a>安装 Next 主题</h2><p>我使用的 <a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">Next</a> 主题</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 项目文件夹</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></tbody></table></figure>
<p>将<code>项目目录</code>下的<code>_config.yml</code> 配置文件中的 <code>theme: landscape</code> 改为 <code>theme: next</code>, 然后重启 Hexo 本地服务，即可在本地看到新的主题样式</p>
<p>如果想改为其他主题，请前往 <a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo Themes</a>，自行选取后，按照说明文档要求自行修改配置</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Hexo 大部份的的配置在<code>项目目录</code>下的<code>_config.yml</code> 中，根据 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">Hexo 官方文档</a>按照自己需要改动即可</p>
<p>自己想个性化配置，例如在文章底部增加版权信息，网站底部字数统计等更多，可以参考 <a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">Hexo 的 Next 主题个性化配置教程</a>，当然这个参考大部分都是 <code>next 5.x</code> 版本，新的版本还是建议参考 <a href="https://github.com/theme-next" target="_blank" rel="noopener">theme-next</a> 中的配置</p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>创建一个新的文章</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new 文章名</span><br></pre></td></tr></tbody></table></figure>
<p>更多说明，参考 <a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">Hexo 写作</a></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h2 id="安装hexo-deployer-git"><a href="#安装hexo-deployer-git" class="headerlink" title="安装hexo-deployer-git"></a>安装 <code>hexo-deployer-git</code></h2><p>首先安装 <a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cnpm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>下面要用到 git 仓库，创建 github.io 仓库</p>
<ol>
<li>点击 <code>New repository</code></li>
<li>输入 <code>Repository name</code>，必需为<code>用户名.github.io</code> 格式</li>
<li>点击按钮 <code>Create repository</code></li>
<li>进入仓库<code>用户名.github.io</code>，点击 <code>Settings</code>，找到 <code>GitHub Pages</code> 模块</li>
<li>点击 <code>Choose a theme</code> 选择一个页面主题</li>
<li>然后这个静态资源存放的远程仓库地址就创建了</li>
</ol>
<h2 id="指定仓库位置"><a href="#指定仓库位置" class="headerlink" title="指定仓库位置"></a>指定仓库位置</h2><p>下面将生成好的静态资源推到远程仓库，先修改博客项目目录下的<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">生成好的静态资源存放的远程仓库地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">[分支名称]</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h2><p>先生成文件后，再将静态资源提交到远程仓库</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># d 是 deploy</span></span><br><span class="line"><span class="comment"># g 是 generate</span></span><br><span class="line"></span><br><span class="line">hexo g -d</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">hexo d -g</span><br></pre></td></tr></tbody></table></figure>
<p>等个一会儿后，在浏览器打开 <code>https://用户名.github.io</code> 就可以访问博客网站了</p>
<hr>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>部署</tag>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Jekyll 的简单安装配置以及部署</title>
    <url>/2018/09/18/Jekyll%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Jekyll 是一个简单的博客形态的静态站点生产机器 </p>
</blockquote>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在本地使用 Jekyll 框架，需要电脑中已安装 <a href="http://git-scm.com" target="_blank" rel="noopener">Git</a>、<a href="http://ruby-lang.org" target="_blank" rel="noopener">Ruby</a></p>
<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装 Git</h2><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a></li>
<li>Mac：使用 <a href="https://brew.sh/index_zh-cn" target="_blank" rel="noopener">Homebrew</a> ：<code>brew install git --with-gettext</code></li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<a id="more"></a>
<h2 id="安装Ruby"><a href="#安装Ruby" class="headerlink" title="安装Ruby"></a>安装 Ruby</h2><p>Ruby 有多个版本，建议使用 <a href="https://rvm.io" target="_blank" rel="noopener">rvm (Ruby Version Manager)</a> 来管理 Ruby 的版本。对于 windows 小伙伴来说，建议<a href="https://rubyinstaller.org/" target="_blank" rel="noopener">使用 Ruby 安装程序</a>进行安装</p>
<p>安装 Ruby</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 Jekyll 需要 Ruby 版本 &gt;= 2.1.0</span></span><br><span class="line">rvm install 2.5.1</span><br></pre></td></tr></tbody></table></figure>
<p>使用 <a href="https://ruby-china.org/wiki/ruby-mirror" target="_blank" rel="noopener">ruby-china 的源镜像</a><br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 替换 rvm 的配置信息</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"ruby_url=https://cache.ruby-china.com/pub/ruby"</span> &gt; ~/.rvm/user/db</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="安装Jekyll"><a href="#安装Jekyll" class="headerlink" title="安装Jekyll"></a>安装 Jekyll</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">gem install bundler jekyll</span><br></pre></td></tr></tbody></table></figure>
<p>国内小伙伴建议先使用 <a href="https://gems.ruby-china.com" target="_blank" rel="noopener">ruby-china 的 Gem 镜像</a></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 替换Gem源</span></span><br><span class="line">gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换 Bundler 的 Gem 源代码镜像命令</span></span><br><span class="line">bundle config mirror.https://rubygems.org https://gems.ruby-china.com</span><br></pre></td></tr></tbody></table></figure>
<h1 id="使用Jekyll"><a href="#使用Jekyll" class="headerlink" title="使用Jekyll"></a>使用 Jekyll</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">Jekyll new 博客文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入博客目录</span></span><br><span class="line"><span class="built_in">cd</span> 博客文件夹</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">bundle install</span><br></pre></td></tr></tbody></table></figure>
<p>查看 <code>jekyll new</code> 更多帮助<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">jekyll new -h</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="本地启动"><a href="#本地启动" class="headerlink" title="本地启动"></a>本地启动</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># s 是 server</span></span><br><span class="line"></span><br><span class="line">jekyll s</span><br></pre></td></tr></tbody></table></figure>
<p>然后在可以本地浏览器打开 <a href="http://localhost:4000，就可以访问启动好的博客啦" target="_blank" rel="noopener">http://localhost:4000，就可以访问启动好的博客啦</a></p>
<p>查看 <code>jekyll server</code> 更多帮助<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">jekyll s -h</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="使用Next主题"><a href="#使用Next主题" class="headerlink" title="使用Next主题"></a>使用 Next 主题</h2><p>我使用的 <a href="https://github.com/Simpleyyt/jekyll-theme-next" target="_blank" rel="noopener">Next</a> 主题</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Simpleyyt/jekyll-theme-next</span><br><span class="line"><span class="built_in">cd</span> jekyll-theme-next</span><br><span class="line">bundle install</span><br><span class="line">jekyll s <span class="comment"># 启动</span></span><br></pre></td></tr></tbody></table></figure>
<p>此时<code>项目目录</code>就是 <code>jekyll-theme-next</code>，修改<code>项目目录</code>下的<code>_config.yml</code> 文件，必须重启 Hexo 本地服务，即可在本地看到新的主题样式</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Jekyll 大部份的的配置在<code>项目目录</code>下的<code>_config.yml</code> 中，根据 <a href="http://jekyllrb.com" target="_blank" rel="noopener">Jekyll 官方文档</a>，<a href="http://jekyll.com.cn" target="_blank" rel="noopener">Jekyll 中文文档</a>和 <a href="http://theme-next.simpleyyt.com/" target="_blank" rel="noopener">Next 文档</a>按照自己需要改动即可</p>
<h2 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h2><p>需要在<code>_posts</code> 文件夹中创建一个新的文件，文件格式为<code>年-月-日-标题.md</code>，<code>年</code>是四位数字，<code>月</code>和<code>日</code>都是两位</p>
<p>更多说明，参考 <a href="https://www.jekyll.com.cn/docs/posts/" target="_blank" rel="noopener">Jekyll 写作</a></p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>部署的基本原理同 <a href="/2018/09/17/Hexo%E7%9A%84%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E9%83%A8%E7%BD%B2#部署">Hexo 的部署</a> , 但是 Jekyll 没有类与 Hexo 的 <code>hexo-deployer-git</code>，所以需要手动把这静态资源的目录<code>_site</code> 的中内容提交到远程就可以了</p>
<hr>
]]></content>
      <categories>
        <category>Jekyll</category>
      </categories>
      <tags>
        <tag>部署</tag>
        <tag>配置</tag>
        <tag>Jekyll</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 动作缓存</title>
    <url>/2018/09/24/Rails%E5%8A%A8%E4%BD%9C%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="动作缓存"><a href="#动作缓存" class="headerlink" title="动作缓存"></a>动作缓存</h1><p>有前置过滤器的动作不能使用页面缓存，例如需要验证身份的页面。此时，应该使用动作缓存。动作缓存的工作原理与页面缓存类似，不过入站请求会经过 Rails 栈处理，以便运行前置过滤器，然后再伺服缓存。这样，可以做身份验证和其他限制，同时还能从缓存的副本中伺服结果。</p>
<div class="note info"><p>动作缓存已从 Rails 4 中删除</p></div>
<p>动作缓存 <a href="https://github.com/rails/actionpack-action_caching" target="_blank" rel="noopener">actionpack-action_caching 的地址</a></p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 Rails 项目中的 <code>Gemfile</code> 文件中添加</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">gem <span class="string">'actionpack-action_caching'</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后执行 <code>bundle install</code> 命令安装</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>详细介绍查看动作缓存 <a href="https://github.com/rails/actionpack-action_caching" target="_blank" rel="noopener">actionpack-action_caching</a></p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListsController</span> &lt; ApplicationController</span></span><br><span class="line">  before_action <span class="symbol">:authenticate</span>, <span class="symbol">except:</span> <span class="symbol">:public</span></span><br><span class="line"></span><br><span class="line">  caches_page   <span class="symbol">:public</span></span><br><span class="line">  caches_action <span class="symbol">:index</span>, <span class="symbol">:show</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListsController</span> &lt; ApplicationController</span></span><br><span class="line">  before_action <span class="symbol">:authenticate</span>, <span class="symbol">except:</span> <span class="symbol">:public</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># simple fragment cache</span></span><br><span class="line">  caches_action <span class="symbol">:current</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># expire cache after an hour</span></span><br><span class="line">  caches_action <span class="symbol">:archived</span>, <span class="symbol">expires_in:</span> <span class="number">1</span>.hour</span><br><span class="line"></span><br><span class="line">  <span class="comment"># cache unless it's a JSON request</span></span><br><span class="line">  caches_action <span class="symbol">:index</span>, <span class="symbol">unless:</span> -&gt; { request.format.json? }</span><br><span class="line"></span><br><span class="line">  <span class="comment"># custom cache path</span></span><br><span class="line">  caches_action <span class="symbol">:show</span>, <span class="symbol">cache_path:</span> { <span class="symbol">project:</span> <span class="number">1</span> }</span><br><span class="line"></span><br><span class="line">  <span class="comment"># custom cache path with a proc</span></span><br><span class="line">  caches_action <span class="symbol">:history</span>, <span class="symbol">cache_path:</span> -&gt; { request.domain }</span><br><span class="line"></span><br><span class="line">  <span class="comment"># custom cache path with a symbol</span></span><br><span class="line">  caches_action <span class="symbol">:feed</span>, <span class="symbol">cache_path:</span> <span class="symbol">:user_cache_path</span></span><br><span class="line"></span><br><span class="line">  protected</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">user_cache_path</span></span></span><br><span class="line">      <span class="keyword">if</span> params[<span class="symbol">:user_id</span>]</span><br><span class="line">        user_list_url(params[<span class="symbol">:user_id</span>], params[<span class="symbol">:id</span>])</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        list_url(params[<span class="symbol">:id</span>])</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 对 HTTP 条件 GET 请求的支持</title>
    <url>/2018/09/27/Rails%E5%AF%B9HTTP%E6%9D%A1%E4%BB%B6GET%E8%AF%B7%E6%B1%82%E7%9A%84%E6%94%AF%E6%8C%81/</url>
    <content><![CDATA[<p><a href="https://ruby-china.github.io/rails-guides/caching_with_rails.html#conditional-get-support" target="_blank" rel="noopener">原文地址</a></p>
<h1 id="对条件-GET-请求的支持"><a href="#对条件-GET-请求的支持" class="headerlink" title="对条件 GET 请求的支持"></a>对条件 GET 请求的支持</h1><p>条件 GET 请求是 HTTP 规范的一个特性，以此告诉 Web 浏览器，GET 请求的响应自上次请求之后没有变化，可以放心从浏览器的缓存中读取。</p>
<a id="more"></a>
<p>为此，要传递 <code>HTTP_IF_NONE_MATCH</code> 和 <code>HTTP_IF_MODIFIED_SINCE</code> 首部，其值分别为唯一的内容标识符和上一次改动时的时间戳。浏览器发送的请求，如果内容标识符（<code>etag</code>）或上一次修改的时间戳与服务器中的版本匹配，那么服务器只需返回一个空响应，把状态设为未修改。</p>
<p>服务器（也就是我们自己）要负责查看最后修改时间戳和 <code>HTTP_IF_NONE_MATCH</code> 首部，判断要不要返回完整的响应。既然 Rails 支持条件 GET 请求，那么这个任务就非常简单：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsController</span> &lt; ApplicationController</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span></span><br><span class="line">    @product = Product.find(params[<span class="symbol">:id</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果根据指定的时间戳和 etag 值判断请求的内容过期了</span></span><br><span class="line">    <span class="comment"># （即需要重新处理）执行这个块</span></span><br><span class="line">    <span class="keyword">if</span> stale?(<span class="symbol">last_modified:</span> @product.updated_at.utc, <span class="symbol">etag:</span> @product.cache_key)</span><br><span class="line">      respond_to <span class="keyword">do</span> <span class="params">|wants|</span></span><br><span class="line">        <span class="comment"># ... 正常处理响应</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 如果请求的内容还新鲜（即未修改），无需做任何事</span></span><br><span class="line">    <span class="comment"># render 默认使用前面 stale? 中的参数做检查，会自动发送 :not_modified 响应</span></span><br><span class="line">    <span class="comment"># 就这样，工作结束</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>除了散列，还可以传入模型。Rails 会使用 <code>updated_at</code> 和 <code>cache_key</code> 方法设定 <code>last_modified</code> 和 <code>etag</code>：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span></span><br><span class="line">    @product = Product.find(params[<span class="symbol">:id</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> stale?(@product)</span><br><span class="line">      respond_to <span class="keyword">do</span> <span class="params">|wants|</span></span><br><span class="line">        <span class="comment"># ... 正常处理响应</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果无需特殊处理响应，而且使用默认的渲染机制（即不使用 <code>respond_to</code>，或者不自己调用 <code>render</code>），可以使用 <code>fresh_when</code> 简化这个过程：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsController</span> &lt; ApplicationController</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 如果请求的内容是新鲜的，自动返回 :not_modified</span></span><br><span class="line">  <span class="comment"># 否则渲染默认的模板（product.*）</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span></span><br><span class="line">    @product = Product.find(params[<span class="symbol">:id</span>])</span><br><span class="line">    fresh_when <span class="symbol">last_modified:</span> @product.published_at.utc, <span class="symbol">etag:</span> @product</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>有时，我们需要缓存响应，例如永不过期的静态页面。为此，可以使用 <code>http_cache_forever</code> 辅助方法，让浏览器和代理无限期缓存。</p>
<p>默认情况下，缓存的响应是私有的，只在用户的 Web 浏览器中缓存。如果想让代理缓存响应，设定 <code>public: true</code>，让代理把缓存的响应提供给所有用户。</p>
<p>使用这个辅助方法时，<code>last_modified</code> 首部的值被设为 <code>Time.new(2011, 1, 1).utc</code>，<code>expires</code> 首部的值被设为 100 年。</p>
<div class="note warning"><p>使用这个方法时要小心，因为浏览器和代理不会作废缓存的响应，除非强制清除浏览器缓存。</p></div>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span></span><br><span class="line">    http_cache_forever(<span class="symbol">public:</span> <span class="literal">true</span>) <span class="keyword">do</span></span><br><span class="line">      render</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="强-Etag-与弱-Etag"><a href="#强-Etag-与弱-Etag" class="headerlink" title="强 Etag 与弱 Etag"></a>强 Etag 与弱 Etag</h2><p>Rails 默认生成弱 ETag。这种 Etag 允许语义等效但主体不完全匹配的响应具有相同的 Etag。如果响应主体有微小改动，而不想重新渲染页面，可以使用这种 Etag。</p>
<p>为了与强 Etag 区别，弱 Etag 前面有 <code>W/</code>。<br></p><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">W/<span class="string">"618bbc92e2d35ea1945008b42799b0e7"</span> <span class="comment"># =&gt; 弱 ETag</span></span><br><span class="line"><span class="string">"618bbc92e2d35ea1945008b42799b0e7"</span>   <span class="comment"># =&gt; 强 ETag</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>与弱 Etag 不同，强 Etag 要求响应完全一样，不能有一个字节的差异。在大型视频或 PDF 文件内部做 Range 查询时用得到。有些 CDN，如 Akamai，只支持强 Etag。如果确实想生成强 Etag，可以这么做：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span></span><br><span class="line">    @product = Product.find(params[<span class="symbol">:id</span>])</span><br><span class="line">    fresh_when <span class="symbol">last_modified:</span> @product.published_at.utc, <span class="symbol">strong_etag:</span> @product</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以直接在响应上设定强 Etag：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">response.strong_etag = response.body</span><br><span class="line"><span class="comment"># =&gt; "618bbc92e2d35ea1945008b42799b0e7"</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 中的 ActiveSupport::Concern</title>
    <url>/2018/09/28/Rails%E4%B8%AD%E7%9A%84ActiveSupport-Concern/</url>
    <content><![CDATA[<h1 id="普通的mixin"><a href="#普通的mixin" class="headerlink" title="普通的mixin"></a>普通的 mixin</h1><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="comment"># self.included是include时的钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">included</span><span class="params">(base)</span></span></span><br><span class="line">    <span class="comment"># base扩展</span></span><br><span class="line">    base.extend ClassMethods</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开base，在base中执行代码</span></span><br><span class="line">    base.class_eval <span class="keyword">do</span></span><br><span class="line">      <span class="comment"># 这里写一个类include时在类需要执行什么动作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">ClassMethods</span></span></span><br><span class="line">    <span class="comment"># 这里写一个类include该module后生成的类方法</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 这里写一个类include该module后生成的实例类方法</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h1 id="使用-ActiveSupport-Concern"><a href="#使用-ActiveSupport-Concern" class="headerlink" title="使用 ActiveSupport::Concern"></a>使用 ActiveSupport::Concern</h1><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'active_support/concern'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="comment"># 扩展当前module</span></span><br><span class="line">  extend ActiveSupport::Concern</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 调用Concern中定义的included方法</span></span><br><span class="line">  included <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 这里写一个类include时在类需要执行什么动作</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 调用Concern中定义的class_methods方法</span></span><br><span class="line">  class_methods <span class="keyword">do</span></span><br><span class="line">    <span class="comment"># 这里写一个类include该module后生成的类方法</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 这里写一个类include该module后生成的实例类方法</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="解读-ActiveSupport-Concern"><a href="#解读-ActiveSupport-Concern" class="headerlink" title="解读 ActiveSupport::Concern"></a>解读 ActiveSupport::Concern</h1><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">ActiveSupport</span></span></span><br><span class="line">  <span class="class"><span class="keyword">module</span> <span class="title">Concern</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义了一个异常类，不能多次include</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MultipleIncludedBlocks</span> &lt; StandardError</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">        <span class="keyword">super</span> <span class="string">"Cannot define multiple 'included' blocks for a Concern"</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># self.extended是extend时的钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">extended</span><span class="params">(base)</span></span></span><br><span class="line">      <span class="comment"># 定义base中的@_dependencies</span></span><br><span class="line">      base.instance_variable_set(<span class="symbol">:</span>@_dependencies, [])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># ruby在include一个module时会调用append_features方法，进行实际的mixin操作，包括增加常量，方法和变量到模块中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append_features</span><span class="params">(base)</span></span></span><br><span class="line">      <span class="keyword">if</span> base.instance_variable_defined?(<span class="symbol">:</span>@_dependencies)</span><br><span class="line">        <span class="comment"># 如果有引入已经定义@_dependencies时，一般是引入一个已经extend这个Concern的module，才会定义@_dependencies</span></span><br><span class="line">        <span class="comment"># 将后extend这个Concern的module放入到@_dependencies中</span></span><br><span class="line">        base.instance_variable_get(<span class="symbol">:</span>@_dependencies) &lt;&lt; <span class="keyword">self</span></span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span> <span class="keyword">if</span> base &lt; <span class="keyword">self</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># @_dependencies是详见上面定义的self.extended</span></span><br><span class="line">        <span class="comment"># 先引入包含在@_dependencies中module</span></span><br><span class="line">        @_dependencies.each { <span class="params">|dep|</span> base.<span class="keyword">include</span>(dep) }</span><br><span class="line">        <span class="keyword">super</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># ClassMethods是详见下面定义的class_methods</span></span><br><span class="line">        <span class="comment"># 如果定义ClassMethods,将ClassMethods中的方法extend到base中</span></span><br><span class="line">        base.extend const_get(<span class="symbol">:ClassMethods</span>) <span class="keyword">if</span> const_defined?(<span class="symbol">:ClassMethods</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># @_included_block是详见下面定义的included方法</span></span><br><span class="line">        <span class="comment"># 如果定义@_included_block,在base中执行@_included_block中的代码</span></span><br><span class="line">        base.class_eval(&amp;@_included_block) <span class="keyword">if</span> instance_variable_defined?(<span class="symbol">:</span>@_included_block)</span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># extend后，将可以使用included这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">included</span><span class="params">(base = <span class="literal">nil</span>, &amp;block)</span></span></span><br><span class="line">      <span class="keyword">if</span> base.<span class="literal">nil</span>?</span><br><span class="line">        <span class="comment"># 判断是否多次include</span></span><br><span class="line">        raise MultipleIncludedBlocks <span class="keyword">if</span> instance_variable_defined?(<span class="symbol">:</span>@_included_block)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 定义类实例类变量</span></span><br><span class="line">        @_included_block = block</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">super</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># extend后，将可以使用class_methods这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_methods</span><span class="params">(&amp;class_methods_module_definition)</span></span></span><br><span class="line">      <span class="comment"># extend时判断当前module是否定义了ClassMethods这个常量，不包括父级</span></span><br><span class="line">      <span class="comment"># 有的话就使用已经定义好的，没有就Module.new一个</span></span><br><span class="line">      mod = const_defined?(<span class="symbol">:ClassMethods</span>, <span class="literal">false</span>) ?</span><br><span class="line">        const_get(<span class="symbol">:ClassMethods</span>) <span class="symbol">:</span></span><br><span class="line">        const_set(<span class="symbol">:ClassMethods</span>, Module.new)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># extend后，调用class_methods方时将块里的定写入到ClassMethods里</span></span><br><span class="line">      mod.module_eval(&amp;class_methods_module_definition)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 片段缓存以及其他缓存</title>
    <url>/2018/09/25/Rails%E7%89%87%E6%AE%B5%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>更多详细查看<a href="https://ruby-china.github.io/rails-guides/caching_with_rails.html#fragment-caching" target="_blank" rel="noopener">原文地址</a></p>
<h1 id="片段缓存"><a href="#片段缓存" class="headerlink" title="片段缓存"></a>片段缓存</h1><p>动态 Web 应用一般使用不同的组件构建页面，不是所有组件都能使用同一种缓存机制。如果页面的不同部分需要使用不同的缓存机制，在不同的条件下失效，可以使用片段缓存（<code>ActionView::Helpers::CacheHelper#cache</code>）。片段缓存把视图逻辑的一部分放在 <code>cache</code> 块中，下次请求使用缓存存储器中的副本伺服<br><a id="more"></a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>如果想缓存页面中的各个商品，可以使用下述代码：<br></p><figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%<span class="ruby"> @products.each <span class="keyword">do</span> <span class="params">|product|</span> </span>%&gt;</span><br><span class="line">  &lt;%<span class="ruby"> cache product <span class="keyword">do</span> </span>%&gt;</span><br><span class="line">    &lt;%=<span class="ruby"> render product </span>%&gt;</span><br><span class="line">  &lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;</span><br><span class="line">&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>首次访问这个页面时，Rails 会创建一个具有唯一键的缓存条目。缓存键类似下面这种</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">views/products/1-201505056193031061005000/bea67108094918eeba42cd4a6e786901</span><br></pre></td></tr></tbody></table></figure>
<p>中间的数字是 <code>product_id</code> 加上商品记录的 <code>updated_at</code> 属性中存储的时间戳。Rails 使用时间戳确保不伺服过期的数据。如果 <code>updated_at</code> 的值变了，Rails 会生成一个新键，然后在那个键上写入一个新缓存，旧键上的旧缓存不再使用。这叫基于键的失效方式</p>
<p>视图片段有变化时（例如视图的 HTML 有变），缓存的片段也失效。缓存键末尾那个字符串是模板树摘要，是基于缓存的视图片段的内容计算的 MD5 哈希值。如果视图片段有变化，MD5 哈希值就变了，因此现有文件失效</p>
<div class="note info"><p>Memcached 等缓存存储器会自动删除旧的缓存文件</p></div>
<p>特定条件下缓存一个片段，可以使用 <code>cache_if</code> 或 <code>cache_unless</code><br></p><figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%<span class="ruby"> cache_if admin?, product <span class="keyword">do</span> </span>%&gt;</span><br><span class="line">  &lt;%=<span class="ruby"> render product </span>%&gt;</span><br><span class="line">&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>render</code> 辅助方法还能缓存渲染集合的单个模板。这甚至比使用 <code>each</code> 的前述示例更好，因为是一次性读取所有缓存模板的，而不是一次读取一个。若想缓存集合，渲染集合时传入 <code>cached: true</code> 选项</p>
<figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%=<span class="ruby"> render <span class="symbol">partial:</span> <span class="string">'products/product'</span>, <span class="symbol">collection:</span> @products, <span class="symbol">cached:</span> <span class="literal">true</span> </span>%&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>上述代码中所有的缓存模板一次性获取，速度更快。此外，尚未缓存的模板也会写入缓存，在下次渲染时获取</p>
<h1 id="俄罗斯套娃缓存"><a href="#俄罗斯套娃缓存" class="headerlink" title="俄罗斯套娃缓存"></a>俄罗斯套娃缓存</h1><p>有时，可能想把缓存的片段嵌套在其他缓存的片段里。这叫俄罗斯套娃缓存（Russian doll caching）<br>俄罗斯套娃缓存的优点是，更新单个商品后，重新生成外层片段时，其他内存片段可以复用<br>前一节说过，如果缓存的文件对应的记录的 <code>updated_at</code> 属性值变了，缓存的文件失效。但是，内层嵌套的片段不失效</p>
<figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%<span class="ruby"> cache product <span class="keyword">do</span> </span>%&gt;</span><br><span class="line">  &lt;%=<span class="ruby"> render product.games </span>%&gt;</span><br><span class="line">&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>上面这个会渲染下面这个</p>
<figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%<span class="ruby"> cache game <span class="keyword">do</span> </span>%&gt;</span><br><span class="line">  &lt;%=<span class="ruby"> render game </span>%&gt;</span><br><span class="line">&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>如果游戏的任何一个属性变了，<code>updated_at</code> 的值会设为当前时间，因此缓存失效。然而，商品对象的 <code>updated_at</code> 属性不变，因此它的缓存不失效，从而导致应用伺服过期的数据。为了解决这个问题，可以使用 <code>touch</code> 方法把模型绑在一起</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &lt; ApplicationRecord</span></span><br><span class="line">  has_many <span class="symbol">:games</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> &lt; ApplicationRecord</span></span><br><span class="line">  belongs_to <span class="symbol">:product</span>, <span class="symbol">touch:</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="管理依赖"><a href="#管理依赖" class="headerlink" title="管理依赖"></a>管理依赖</h1><p>为了正确地让缓存失效，要正确地定义缓存依赖。Rails 足够智能，能处理常见的情况，无需自己指定。但是有时需要处理自定义的辅助方法（以此为例），因此要自行定义</p>
<h2 id="隐式依赖"><a href="#隐式依赖" class="headerlink" title="隐式依赖"></a>隐式依赖</h2><p>多数模板依赖可以从模板中的 <code>render</code> 调用中推导出来。下面举例说明 <code>ActionView::Digestor</code> 知道如何解码的 <code>render</code> 调用</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">render <span class="symbol">partial:</span> <span class="string">"comments/comment"</span>, <span class="symbol">collection:</span> commentable.comments</span><br><span class="line">render <span class="string">"comments/comments"</span></span><br><span class="line">render <span class="string">'comments/comments'</span></span><br><span class="line">render(<span class="string">'comments/comments'</span>)</span><br><span class="line"></span><br><span class="line">render <span class="string">"header"</span> =&gt; render(<span class="string">"comments/header"</span>)</span><br><span class="line"></span><br><span class="line">render(@topic)         <span class="comment"># =&gt; render("topics/topic")</span></span><br><span class="line">render(topics)         <span class="comment"># =&gt; render("topics/topic")</span></span><br><span class="line">render(message.topics) <span class="comment"># =&gt; render("topics/topic")</span></span><br></pre></td></tr></tbody></table></figure>
<p>而另一方面，有些调用要做修改方能让缓存正确工作。例如，如果传入自定义的集合，要把下述代码：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">render @project.documents.where(<span class="symbol">published:</span> <span class="literal">true</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>改为</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">render <span class="symbol">partial:</span> <span class="string">"documents/document"</span>, <span class="symbol">collection:</span> @project.documents.where(<span class="symbol">published:</span> <span class="literal">true</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="显式依赖"><a href="#显式依赖" class="headerlink" title="显式依赖"></a>显式依赖</h2><p>有时，模板依赖推导不出来。在辅助方法中渲染时经常是这样</p>
<figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%=<span class="ruby"> render_sortable_todolists @project.todolists </span>%&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>此时，要使用一种特殊的注释格式：<br></p><figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;%# Template Dependency: todolists/todolist %&gt;</span></span><br><span class="line">&lt;%=<span class="ruby"> render_sortable_todolists @project.todolists </span>%&gt;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>某些情况下，例如设置单表继承，可能要显式定义一堆依赖。此时无需写出每个模板，可以使用通配符匹配一个目录中的全部模板：<br></p><figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;%# Template Dependency: events/* %&gt;</span></span><br><span class="line">&lt;%=<span class="ruby"> render_categorizable_events @person.events </span>%&gt;</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>对集合缓存来说，如果局部模板不是以干净的缓存调用开头，依然可以使用集合缓存，不过要在模板中的任意位置添加一种格式特殊的注释，如下所示：</p>
<figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;%# Template Collection: notification %&gt;</span></span><br><span class="line">&lt;%<span class="ruby"> my_helper_that_calls_cache(some_arg, notification) <span class="keyword">do</span> </span>%&gt;</span><br><span class="line">  &lt;%=<span class="ruby"> notification.name </span>%&gt;</span><br><span class="line">&lt;%<span class="ruby"> <span class="keyword">end</span> </span>%&gt;</span><br></pre></td></tr></tbody></table></figure>
<h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>如果在缓存的块中使用辅助方法，而后更新了辅助方法，还要更新缓存。具体方法不限，只要能改变模板文件的 MD5 值就行。推荐的方法之一是添加一个注释，如下所示：</p>
<figure class="highlight erb"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;%# Helper Dependency Updated: Jul 28, 2015 at 7pm %&gt;</span></span><br><span class="line">&lt;%=<span class="ruby"> some_helper_method(person) </span>%&gt;</span><br></pre></td></tr></tbody></table></figure>
<h1 id="低层缓存"><a href="#低层缓存" class="headerlink" title="低层缓存"></a>低层缓存</h1><p>有时需要缓存特定的值或查询结果，而不是缓存视图片段。Rails 的缓存机制能存储任何类型的信息。</p>
<p>实现低层缓存最有效的方式是使用 <code>Rails.cache.fetch</code> 方法。这个方法既能读取也能写入缓存。传入单个参数时，获取指定的键，返回缓存中的值。如果传入块，块中的代码在缓存缺失时执行。块返回的值将写入缓存，存在指定键的名下，然后返回那个返回值。如果命中缓存，直接返回缓存的值，而不执行块中的代码。</p>
<p>下面举个例子。应用中有个 <code>Product</code> 模型，它有个实例方法，在竞争网站中查找商品的价格。这个方法返回的数据特别适合使用低层缓存：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> &lt; ApplicationRecord</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">competing_price</span></span></span><br><span class="line">    Rails.cache.fetch(<span class="string">"<span class="subst">#{cache_key}</span>/competing_price"</span>, <span class="symbol">expires_in:</span> <span class="number">12</span>.hours) <span class="keyword">do</span></span><br><span class="line">      Competitor::API.find_price(id)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>注意，这个示例使用了 <code>cache_key</code> 方法，因此得到的缓存键类似这种：<code>products/233-20140225082222765838000/competing_price</code>。<code>cache_key</code> 方法根据模型的 <code>id</code> 和 <code>updated_at</code> 属性生成一个字符串。这是常见的约定，有个好处是，商品更新后缓存自动失效。一般来说，使用低层缓存缓存实例层信息时，需要生成缓存键。</p></div>
<h1 id="SQL-缓存"><a href="#SQL-缓存" class="headerlink" title="SQL 缓存"></a>SQL 缓存</h1><p>查询缓存是 Rails 提供的一个功能，把各个查询的结果集缓存起来。如果在同一个请求中遇到了相同的查询，Rails 会使用缓存的结果集，而不再次到数据库中运行查询。</p>
<p>例如：<br></p><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductsController</span> &lt; ApplicationController</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span></span></span><br><span class="line">    <span class="comment"># 运行查找查询</span></span><br><span class="line">    @products = Product.all</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再次运行相同的查询</span></span><br><span class="line">    @products = Product.all</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>再次运行相同的查询时，根本不会发给数据库。首次运行查询得到的结果存储在查询缓存中（内存里），第二次查询从内存中获取。</p>
<p>然而要知道，查询缓存在动作开头创建，到动作末尾销毁，只在动作的存续时间内存在。如果想持久化存储查询结果，使用低层缓存也能实现</p>
<hr>
]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 页面缓存</title>
    <url>/2018/09/23/Rails%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<h1 id="页面缓存"><a href="#页面缓存" class="headerlink" title="页面缓存"></a>页面缓存</h1><p>页面缓存是 Rails 提供的一种缓存机制，让 Web 服务器（如 Apache 和 NGINX）直接访问静态页面，而不经由 Rails 动态生成。虽然这种缓存的速度超快，但是不适用于所有情况（例如需要验证身份的页面）。此外，因为 Web 服务器直接从文件系统中访问文件，所以要自行实现缓存失效机制</p>
<div class="note info"><p>页面缓存已从 Rails 4 中删除</p></div>
<p>页面缓存 <a href="https://github.com/rails/actionpack-page_caching" target="_blank" rel="noopener">actionpack-page_caching 的地址</a></p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>在 Rails 项目中的 <code>Gemfile</code> 文件中添加</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">gem <span class="string">'actionpack-page_caching'</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后执行 <code>bundle install</code> 命令安装</p>
<h1 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h1><p>设置缓存文件存放位置 <code>page_cache_directory</code></p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.action_controller.page_cache_directory = <span class="string">"<span class="subst">#{Rails.root}</span>/public/cached_pa​​ges"</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以给 <code>Controller</code> 单独设置，可以使用以下三种方式</p>
<p>指向一个 <code>lambda</code> 表达式，运行时会自动调用 <code>lambda</code> 的 <code>call</code> 方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeblogController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="keyword">self</span>.page_cache_directory = -&gt; { Rails.root.join(<span class="string">"public"</span>, request.domain) }</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可指向一个方法的 <code>symbol</code> 名</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeblogController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="keyword">self</span>.page_cache_directory = <span class="symbol">:domain_cache_directory</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">domain_cache_directory</span></span></span><br><span class="line">      Rails.root.join(<span class="string">"public"</span>, request.domain)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<p>也可以指向实现 <code>call</code> 类方法的对象</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DomainCacheDirectory</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">call</span><span class="params">(request)</span></span></span><br><span class="line">    Rails.root.join(<span class="string">"public"</span>, request.domain)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeblogController</span> &lt; ApplicationController</span></span><br><span class="line">  <span class="keyword">self</span>.page_cache_directory = DomainCacheDirectory</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h2><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeblogController</span> &lt; ActionController::Base</span></span><br><span class="line">  caches_page <span class="symbol">:show</span>, <span class="symbol">:new</span> <span class="comment"># 设置new和show页面缓存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 生成public/cached_pa​​ges/weblog/new.html</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">new</span></span></span><br><span class="line">    @list = List.new</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 生成public/cached_pa​​ges/weblog/:id.html</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">show</span></span></span><br><span class="line">    @list = List.find(params[<span class="symbol">:id</span>])</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="更新页面缓存"><a href="#更新页面缓存" class="headerlink" title="更新页面缓存"></a>更新页面缓存</h2><p>数据更新后，将已生成的页面缓存过期</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeblogController</span> &lt; ActionController::Base</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span></span></span><br><span class="line">    List.update(params[<span class="symbol">:list</span>][<span class="symbol">:id</span>], params[<span class="symbol">:list</span>])</span><br><span class="line">    <span class="comment"># 设置public/cached_pa​​ges/weblog/:id.html已过期</span></span><br><span class="line">    expire_page <span class="symbol">action:</span> <span class="string">'show'</span>, <span class="symbol">id:</span> params[<span class="symbol">:list</span>][<span class="symbol">:id</span>]</span><br><span class="line">    <span class="comment"># 跳转到show，生成新的public/cached_pa​​ges/weblog/:id.html</span></span><br><span class="line">    redirect_to <span class="symbol">action:</span> <span class="string">'show'</span>, <span class="symbol">id:</span> params[<span class="symbol">:list</span>][<span class="symbol">:id</span>]</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx 配置</h2><p>如果页面缓存文件存在，将页面缓存作为响应内容返回</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># Index HTML Files</span></span><br><span class="line"><span class="attribute">if</span> (-f <span class="variable">$document_root</span>/cached_pa​​ges/<span class="variable">$uri</span>/index.html) {</span><br><span class="line">  <span class="attribute">rewrite</span> (.*) /cached_pa​​ges/<span class="variable">$1</span>/index.html <span class="literal">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># Other HTML Files</span></span><br><span class="line"><span class="attribute">if</span> (-f <span class="variable">$document_root</span>/cached_pa​​ges/<span class="variable">$uri</span>.html) {</span><br><span class="line">  <span class="attribute">rewrite</span> (.*) /cached_pa​​ges/<span class="variable">$1</span>.html <span class="literal">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"># All</span></span><br><span class="line"><span class="attribute">if</span> (-f <span class="variable">$document_root</span>/cached_pa​​ges/<span class="variable">$uri</span>) {</span><br><span class="line">  <span class="attribute">rewrite</span> (.*) /cached_pa​​ges/<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>Rails 缓存存储器</title>
    <url>/2018/09/26/Rails%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Rails 为存储缓存数据（SQL 缓存和页面缓存除外）提供了不同的存储器。</p>
</blockquote>
<p><a href="https://ruby-china.github.io/rails-guides/caching_with_rails.html#cache-stores" target="_blank" rel="noopener">原文地址</a></p>
<a id="more"></a>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p><code>config.cache_store</code> 配置选项用于设定应用的默认缓存存储器。可以设定其他参数，传给缓存存储器的构造方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.cache_store = <span class="symbol">:memory_store</span>, { <span class="symbol">size:</span> <span class="number">64</span>.megabytes }</span><br></pre></td></tr></tbody></table></figure>
<div class="note warning"><p>此外，还可以在配置块外部调用 <code>ActionController::Base.cache_store</code>。</p></div>
<p>缓存存储器通过 <code>Rails.cache</code> 访问。</p>
<h1 id="ActiveSupport-Cache-Store"><a href="#ActiveSupport-Cache-Store" class="headerlink" title="ActiveSupport::Cache::Store"></a>ActiveSupport::Cache::Store</h1><p>这个类是在 Rails 中与缓存交互的基础。这是个抽象类，不能直接使用。你必须根据存储器引擎具体实现这个类。Rails 提供了几个实现，说明如下。</p>
<p>主要调用的方法有 <code>read</code>、<code>write</code>、<code>delete</code>、<code>exist?</code> 和 <code>fetch</code>。<code>fetch</code> 方法接受一个块，返回缓存中现有的值，或者把新值写入缓存。</p>
<p>所有缓存实现有些共用的选项，可以传给构造方法，或者传给与缓存条目交互的各个方法。</p>
<ul>
<li><code>:namespace</code>：在缓存存储器中创建命名空间。如果与其他应用共用同一个缓存存储器，这个选项特别有用。</li>
<li><code>:compress</code>：指定压缩缓存。通过缓慢的网络传输大量缓存时用得着。</li>
<li><code>:compress_threshold</code>：与 <code>:compress</code> 选项搭配使用，指定一个阈值，未达到时不压缩缓存。默认为 16 千字节。</li>
<li><code>:expires_in</code>：为缓存条目设定失效时间（秒数），失效后自动从缓存中删除。</li>
<li><code>:race_condition_ttl</code>：与 <code>:expires_in</code> 选项搭配使用。避免多个进程同时重新生成相同的缓存条目（也叫 dog pile effect），防止让缓存条目过期时出现条件竞争。这个选项设定在重新生成新值时失效的条目还可以继续使用多久（秒数）。如果使用 <code>:expires_in</code> 选项，最好也设定这个选项。</li>
</ul>
<h3 id="自定义缓存存储器"><a href="#自定义缓存存储器" class="headerlink" title="自定义缓存存储器"></a>自定义缓存存储器</h3><p>缓存存储器可以自己定义，只需扩展 <code>ActiveSupport::Cache::Store</code> 类，实现相应的方法。这样，你可以把任何缓存技术带到你的 Rails 应用中。</p>
<p>若想使用自定义的缓存存储器，只需把 <code>cache_store</code> 设为自定义类的实例：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.cache_store = MyCacheStore.new</span><br></pre></td></tr></tbody></table></figure>
<h1 id="ActiveSupport-Cache-MemoryStore"><a href="#ActiveSupport-Cache-MemoryStore" class="headerlink" title="ActiveSupport::Cache::MemoryStore"></a>ActiveSupport::Cache::MemoryStore</h1><p>这个缓存存储器把缓存条目放在内存中，与 Ruby 进程放在一起。可以把<code>:size</code> 选项传给构造方法，指定缓存的大小限制（默认为 <code>32Mb</code>）。超过分配的大小后，会清理缓存，把最不常用的条目删除。</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.cache_store = <span class="symbol">:memory_store</span>, { <span class="symbol">size:</span> <span class="number">64</span>.megabytes }</span><br></pre></td></tr></tbody></table></figure>
<p>如果运行多个 Ruby on Rails 服务器进程（例如使用 Phusion Passenger 或 Puma 集群模式），各个实例之间无法共享缓存数据。这个缓存存储器不适合大型应用使用。不过，适合只有几个服务器进程的低流量小型应用使用，也适合在开发环境和测试环境中使用</p>
<h1 id="ActiveSupport-Cache-FileStore"><a href="#ActiveSupport-Cache-FileStore" class="headerlink" title="ActiveSupport::Cache::FileStore"></a>ActiveSupport::Cache::FileStore</h1><p>这个缓存存储器使用文件系统存储缓存条目。初始化这个存储器时，必须指定存储文件的目录：</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.cache_store = <span class="symbol">:file_store</span>, <span class="string">"/path/to/cache/directory"</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用这个缓存存储器时，在同一台主机中运行的多个服务器进程可以共享缓存。这个缓存存储器适合一到两个主机的中低流量网站使用。运行在不同主机中的多个服务器进程若想共享缓存，可以使用共享的文件系统，但是不建议这么做。</p>
<p>缓存量一直增加，直到填满磁盘，所以建议你定期清理旧缓存条目。</p>
<p>这是默认的缓存存储器</p>
<h1 id="ActiveSupport-Cache-MemCacheStore"><a href="#ActiveSupport-Cache-MemCacheStore" class="headerlink" title="ActiveSupport::Cache::MemCacheStore"></a>ActiveSupport::Cache::MemCacheStore</h1><p>这个缓存存储器使用 Danga 的 <code>memcached</code> 服务器为应用提供中心化缓存。Rails 默认使用自带的 <code>dalli</code> gem。这是生产环境的网站目前最常使用的缓存存储器。通过它可以实现单个共享的缓存集群，效率很高，有较好的冗余。</p>
<p>初始化这个缓存存储器时，要指定集群中所有 <code>memcached</code> 服务器的地址。如果不指定，假定 <code>memcached</code> 运行在本地的默认端口上，但是对大型网站来说，这样做并不好。</p>
<p>这个缓存存储器的 <code>write</code> 和 <code>fetch</code> 方法接受两个额外的选项，以便利用 <code>memcached</code> 的独有特性。指定<code>:raw</code> 时，直接把值发给服务器，不做序列化。值必须是字符串或数字。<code>memcached</code> 的直接操作，如 <code>increment</code> 和 <code>decrement</code>，只能用于原始值。还可以指定<code>:unless_exist</code> 选项，不让 <code>memcached</code> 覆盖现有条目。</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.cache_store = <span class="symbol">:mem_cache_store</span>, <span class="string">"cache-1.example.com"</span>, <span class="string">"cache-2.example.com"</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="ActiveSupport-Cache-NullStore"><a href="#ActiveSupport-Cache-NullStore" class="headerlink" title="ActiveSupport::Cache::NullStore"></a>ActiveSupport::Cache::NullStore</h1><p>这个缓存存储器只应该在开发或测试环境中使用，它并不存储任何信息。在开发环境中，如果代码直接与 <code>Rails.cache</code> 交互，但是缓存可能对代码的结果有影响，可以使用这个缓存存储器。在这个缓存存储器上调用 <code>fetch</code> 和 <code>read</code> 方法不返回任何值。</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">config.cache_store = <span class="symbol">:null_store</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="缓存键"><a href="#缓存键" class="headerlink" title="缓存键"></a>缓存键</h1><p>缓存中使用的键可以是能响应 <code>cache_key</code> 或 <code>to_param</code> 方法的任何对象。如果想定制生成键的方式，可以覆盖 <code>cache_key</code> 方法。Active Record 根据类名和记录 ID 生成缓存键。</p>
<p>缓存键的值可以是散列或数组：<br></p><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个有效的缓存键</span></span><br><span class="line">Rails.cache.read(<span class="symbol">site:</span> <span class="string">"mysite"</span>, <span class="symbol">owners:</span> [owner_1, owner_2])</span><br></pre></td></tr></tbody></table></figure><p></p>
<p><code>Rails.cache</code> 使用的键与存储引擎使用的并不相同，存储引擎使用的键可能含有命名空间，或者根据后端的限制做调整。这意味着，使用 <code>Rails.cache</code> 存储值时使用的键可能无法用于供 <code>dalli</code> gem 获取缓存条目。然而，你也无需担心会超出 <code>memcached</code> 的大小限制，或者违背句法规则</p>
<hr>
]]></content>
      <categories>
        <category>Rails</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>Rails</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 中的 include，extend 与 prepend</title>
    <url>/2018/09/30/Ruby%E4%B8%AD%E7%9A%84include%EF%BC%8Cextend%E4%B8%8Eprepend/</url>
    <content><![CDATA[<h1 id="include-extend-prepend"><a href="#include-extend-prepend" class="headerlink" title="include, extend, prepend"></a>include, extend, prepend</h1><p>参考地址：<a href="https://ruby-china.org/topics/21501" target="_blank" rel="noopener">ruby include extend prepend 使用方法</a><br><a id="more"></a><br></p><figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">A</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    puts <span class="string">'a method'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">aa_method</span></span></span><br><span class="line">    puts <span class="string">'aa method'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">B</span></span></span><br><span class="line">  extend A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span></span></span><br><span class="line">  extend A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BB</span></span></span><br><span class="line">  <span class="keyword">include</span> A</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span></span></span><br><span class="line">  prepend A</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    puts <span class="string">'a method in CC'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">B.ancestors <span class="comment"># =&gt; [B]</span></span><br><span class="line">C.ancestors <span class="comment"># =&gt; [C, A]</span></span><br><span class="line">AA.ancestors <span class="comment"># =&gt; [AA, Object, Kernel, BasicObject]</span></span><br><span class="line">BB.ancestors <span class="comment"># =&gt; [BB, A, Object, Kernel, BasicObject]</span></span><br><span class="line">CC.ancestors <span class="comment"># =&gt; [A, CC, Object, Kernel, BasicObject]</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>BB 将新增一个类方法，AA 的祖先链中没有 A<br>CC 将新增一个实例方法，BB 的祖先链中有 A</p>
<p>Ruby <code>prepend</code> 与 <code>include</code> 类似，首先都是添加实例方法的，不同的是扩展 module 在祖先链上的放置位置不同</p>
<h1 id="当调用方法时，-Ruby是如何找到方法定义的"><a href="#当调用方法时，-Ruby是如何找到方法定义的" class="headerlink" title="当调用方法时， Ruby是如何找到方法定义的"></a>当调用方法时， Ruby 是如何找到方法定义的</h1><ol>
<li>实例方法，首先在实例中查找，然后再实例对象的单件类中查找，之后沿祖先链依次向上找</li>
<li>类方法，首先在类的单件类中查找，然后沿着类的单件类的祖先链一次向上找（类的单件类的祖先链 = 类的祖先链的各个节点的单件类组成的链）</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 中的钩子方法</title>
    <url>/2018/09/29/Ruby%E4%B8%AD%E7%9A%84%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>钩子方法提供了一种方式用于在程序运行时扩展程序的行为</p>
</blockquote>
<p>参考地址：<a href="https://ruby-china.org/topics/25397" target="_blank" rel="noopener">Ruby 中一些重要的钩子方法</a></p>
<a id="more"></a>
<h1 id="included"><a href="#included" class="headerlink" title="included"></a>included</h1><p><code>included</code> 方法是基于 <code>include</code> 的方法，可以在一些 <code>module</code> 或者 <code>class</code> 中 <code>include</code> 了一个 <code>module</code> 时它会被调用。实际在执行 <code>included</code> 之前，模块中的 <code>append_features</code> 被调用并执行具体的 <code>include</code> 操作，注意使用时不要随意覆盖 Ruby 的 <code>append_features</code> 方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">included</span><span class="params">(base)</span></span></span><br><span class="line">    puts <span class="string">"<span class="subst">#{base}</span> included <span class="subst">#{<span class="keyword">self</span>}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    puts <span class="string">"a_method in M"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; "C included M"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">O</span></span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<p>当执行 <code>include M</code> 时，M 中的 <code>included</code> 方法将会被调用，<code>base</code> 既是执行 <code>include</code> 时包含该 <code>module</code> 的类名</p>
<h1 id="extended"><a href="#extended" class="headerlink" title="extended"></a>extended</h1><p>扩展 (extend) 一个模块，这与 包含 (<code>include</code>) 有点不同。 <code>extend</code> 是将定义在 模块 (module) 内的方法应用为类的方法，而不是实例的方法，<code>extended</code> 就是 <code>extend</code> 相对应的钩子方法，注意使用时不要随意覆盖 Ruby 的 <code>extend_object</code> 方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">extended</span><span class="params">(base)</span></span></span><br><span class="line">    puts <span class="string">"<span class="subst">#{base}</span> extended <span class="subst">#{<span class="keyword">self</span>}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    puts <span class="string">"a_method in M"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  extend M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; "C extended M"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">O</span></span></span><br><span class="line">  extend M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; "O extended M"</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="prepended"><a href="#prepended" class="headerlink" title="prepended"></a>prepended</h1><p><code>prepend</code> 是在 Ruby 2.0 中引入的，并且与 <code>include</code> 和 <code>extend</code> 很不一样。 使用 <code>include</code> 和 <code>extend</code> 引入的方法可以被目标模块 / 类重新定义覆盖，而 <code>prepend</code> 是不一样的，它会将 <code>prepend</code> 引入的模块 中的方法覆盖掉我们模块 / 类中定义的方法，<code>prepended</code> 就是 <code>prepend</code> 的钩子方法，注意使用时不要随意覆盖 Ruby 的 <code>prepend_features</code> 方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">prepended</span><span class="params">(base)</span></span></span><br><span class="line">    puts <span class="string">"<span class="subst">#{base}</span> prepended to <span class="subst">#{<span class="keyword">self</span>}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    puts <span class="string">"a_method in M"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  prepend M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; "C prepended to M"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">O</span></span></span><br><span class="line">  prepend M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; "O prepended to M"</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="inherited"><a href="#inherited" class="headerlink" title="inherited"></a>inherited</h1><p>继承是面向对象中一个最重要的概念。Ruby 是一门面向对象的编程语言，并且提供了从基 / 父类继承一个子类的功能，<code>inherited</code> 就是继承的钩子方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">inherited</span><span class="params">(base)</span></span></span><br><span class="line">    puts <span class="string">"<span class="subst">#{base}</span> inherits <span class="subst">#{<span class="keyword">self</span>}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    puts <span class="string">"a_method in M"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &lt; M;</span> <span class="keyword">end</span></span><br><span class="line"><span class="comment"># =&gt; "C inherits M"</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="method的钩子方法"><a href="#method的钩子方法" class="headerlink" title="method的钩子方法"></a>method 的钩子方法</h1><p>定义，删除，取消当前类中定义的方法时会触发类或者单例类的相对应的钩子方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">method_added</span><span class="params">(method_name)</span></span></span><br><span class="line">    puts <span class="string">"Adding <span class="subst">#{method_name.inspect}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">method_removed</span><span class="params">(method_name)</span></span></span><br><span class="line">    puts <span class="string">"Removing <span class="subst">#{method_name.inspect}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">method_undefined</span><span class="params">(method_name)</span></span></span><br><span class="line">    puts <span class="string">"Undefined <span class="subst">#{method_name.inspect}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发singleton_method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">singleton_method_added</span><span class="params">(method_name)</span></span></span><br><span class="line">    puts <span class="string">"Adding singleton <span class="subst">#{method_name.inspect}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发singleton_method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">singleton_method_removed</span><span class="params">(method_name)</span></span></span><br><span class="line">    puts <span class="string">"Removing singleton <span class="subst">#{method_name.inspect}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发singleton_method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">singleton_method_undefined</span><span class="params">(method_name)</span></span></span><br><span class="line">    puts <span class="string">"Undefined singleton <span class="subst">#{method_name.inspect}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发singleton_method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">singleton_class_method_added</span><span class="params">()</span></span>; <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 触发method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">class_method_added</span><span class="params">()</span></span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发singleton_method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">singleton_class_method_removed</span><span class="params">()</span></span>; <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 触发method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">class_method_removed</span><span class="params">()</span></span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发singleton_method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">singleton_class_method_undefined</span><span class="params">()</span></span>; <span class="keyword">end</span></span><br><span class="line">  <span class="comment"># 触发method_added钩子方法</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">class_method_undefined</span><span class="params">()</span></span>; <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> &lt;&lt; self</span></span><br><span class="line">    <span class="comment"># 触发singleton_method_removed钩子方法</span></span><br><span class="line">    remove_method <span class="symbol">:singleton_class_method_removed</span></span><br><span class="line">    <span class="comment"># 触发singleton_method_undefined钩子方法</span></span><br><span class="line">    undef_method <span class="symbol">:singleton_class_method_undefined</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 触发method_removed钩子方法</span></span><br><span class="line">  remove_method <span class="symbol">:class_method_removed</span></span><br><span class="line">  <span class="comment"># 触发method_undefined钩子方法</span></span><br><span class="line">  undef_method <span class="symbol">:class_method_undefined</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding singleton :singleton_method_added</span></span><br><span class="line"><span class="comment"># Adding singleton :singleton_method_removed</span></span><br><span class="line"><span class="comment"># Adding singleton :singleton_method_undefined</span></span><br><span class="line"><span class="comment"># Adding singleton :singleton_class_method_added</span></span><br><span class="line"><span class="comment"># Adding :class_method_added</span></span><br><span class="line"><span class="comment"># Adding singleton :singleton_class_method_removed</span></span><br><span class="line"><span class="comment"># Adding :class_method_removed</span></span><br><span class="line"><span class="comment"># Adding singleton :singleton_class_method_undefined</span></span><br><span class="line"><span class="comment"># Adding :class_method_undefined</span></span><br><span class="line"><span class="comment"># Removing singleton :singleton_class_method_removed</span></span><br><span class="line"><span class="comment"># Undefined singleton :singleton_class_method_undefined</span></span><br><span class="line"><span class="comment"># Removing :class_method_removed</span></span><br><span class="line"><span class="comment"># Undefined :class_method_undefined</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 的 load，require, autoload</title>
    <url>/2018/10/01/Ruby%E7%9A%84load%EF%BC%8Crequire-autoload/</url>
    <content><![CDATA[<!-- * 加载其他文件 -->
<p>参考地址：<a href="https://ruby-china.org/topics/35350" target="_blank" rel="noopener">Ruby 中 require,load,autoload,extend,include,prepend 的区别</a></p>
<h1 id="load-filename-wrap-false-gt-true"><a href="#load-filename-wrap-false-gt-true" class="headerlink" title="load(filename, wrap=false) # => true"></a>load(filename, wrap=false) # =&gt; true</h1><p>每次调用都会加载并执行文件文件名中的 Ruby 程序。如果该文件不在绝对路径中，则在 <code>$:</code> 中查找该文件。如果 <code>wrap</code> 参数为 <code>true</code>，则加载脚本在匿名模块下执行，从而保护调用程序的全局名称空间。任何情况下，加载文件中的任何局部变量都不会加载到调用程序的环境中<br><a id="more"></a></p>
<h1 id="require-name-gt-true-or-false"><a href="#require-name-gt-true-or-false" class="headerlink" title="require(name) # => true or false"></a>require(name) # =&gt; true or false</h1><p>加载指定名称的文件，如果加载成功返回 <code>true</code>, 如果已经加载返回 <code>false</code><br>如果文件不在绝对路径中，则将在 <code>$LOAD_PATH</code> <code>($:)</code> 中查找<br>如果文件名后缀为<code>.rb</code>，则加载源文件。如果扩展名是当前系统平台上的二进制库文件，如<code>.so</code>，<code>.o</code> 或者<code>.dll</code>，则 Ruby 会二进制库加载为 Ruby 扩展。否则，Ruby 会尝试添加<code>.rb</code>，<code>.so</code> 等直到找到为止。否则，就会触发 LoadError 异常<br>Ruby 扩展名给出的文件名可以使用任何共享库扩展，例如，在 Linux 上，套接字扩展名为 <code>socket.so</code>，<code>require "socket.dll"</code> 将加载套接字扩展名<br>加载文件的路径将被添加到 <code>$LOADED_FEATURES</code> <code>($")</code> 中<br>加载的源文件中的任何常量或全局变量都将在调用程序的全局命名空间中可用</p>
<h1 id="autoload-module-filename-gt-nil"><a href="#autoload-module-filename-gt-nil" class="headerlink" title="autoload(module, filename) # => nil"></a>autoload(module, filename) # =&gt; nil</h1><p><code>module</code> 通常是模块名或者类名，只有在调用模块或者类时才会加载文件</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># m.rb</span></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  puts <span class="string">'Load M module'</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">hello</span></span></span><br><span class="line">      puts <span class="string">'Hello'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## require ：只加载一次</span></span><br><span class="line">puts <span class="string">"first load: <span class="subst">#{(<span class="keyword">require</span> <span class="string">'./m.rb'</span>)}</span>"</span></span><br><span class="line"><span class="comment">#= &gt; load M module</span></span><br><span class="line"><span class="comment">#= &gt; first load: true</span></span><br><span class="line">puts <span class="string">"load again: <span class="subst">#{(<span class="keyword">require</span> <span class="string">'./m.rb'</span>)}</span>"</span></span><br><span class="line"><span class="comment">#= &gt; load again: false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># load ：多次加载</span></span><br><span class="line">puts <span class="string">"first load: <span class="subst">#{(load <span class="string">'./m.rb'</span>)}</span>"</span></span><br><span class="line"><span class="comment">#= &gt; load M module</span></span><br><span class="line"><span class="comment">#= &gt; first load: true</span></span><br><span class="line">puts <span class="string">"load again: <span class="subst">#{(load <span class="string">'./m.rb'</span>)}</span>"</span></span><br><span class="line"><span class="comment">#= &gt; load M module</span></span><br><span class="line"><span class="comment">#= &gt; load again: true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># autoload ：调用时才加载</span></span><br><span class="line">puts <span class="string">"first load: <span class="subst">#{autoload(<span class="symbol">:M</span>,<span class="string">'./m.rb'</span>)}</span>"</span></span><br><span class="line"><span class="comment">#= &gt; first load:</span></span><br><span class="line">puts <span class="string">"load again: <span class="subst">#{autoload(<span class="symbol">:M</span>,<span class="string">'./m.rb'</span>)}</span>"</span></span><br><span class="line"><span class="comment">#= &gt; load again:</span></span><br><span class="line"></span><br><span class="line">M::A.hello</span><br><span class="line"><span class="comment"># =&gt; Load M module</span></span><br><span class="line"><span class="comment">#= &gt; Hello</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
      </tags>
  </entry>
  <entry>
    <title>Ruby 元编程 - 法术手册</title>
    <url>/2018/09/20/Ruby%E5%85%83%E7%BC%96%E7%A8%8B-%E6%B3%95%E6%9C%AF%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>这里列出了《Ruby 元编程》介绍的所用法术 </p>
</blockquote>
<h1 id="环绕别名-Around-Alias"><a href="#环绕别名-Around-Alias" class="headerlink" title="环绕别名 Around Alias"></a>环绕别名 Around Alias</h1><p>从一个重新定义的方法中调用原始的、被重命名的版本</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  alias_method <span class="symbol">:old_reverse</span>, <span class="symbol">:reverse</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span></span><br><span class="line">    <span class="string">"x<span class="subst">#{old_reverse}</span>x"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'xcbax'</span></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<h1 id="白板类-Blank-Slate"><a href="#白板类-Blank-Slate" class="headerlink" title="白板类 Blank Slate"></a>白板类 Blank Slate</h1><p>移除一个对象中的所有方法，以便吧他们转换成幽灵方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(name, *args)</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#{name}</span> is a ghost method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">obj.to_s <span class="comment"># =&gt; "#&lt;C:...&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &lt; BasicObject</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(name, *args)</span></span></span><br><span class="line">    <span class="string">"<span class="subst">#{name}</span> is a ghost method"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">blank_slate = B.new</span><br><span class="line">blank_slate.to_s <span class="comment"># =&gt; "to_s is a ghost method"</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="类扩展-Class-Extension"><a href="#类扩展-Class-Extension" class="headerlink" title="类扩展 Class Extension"></a>类扩展 Class Extension</h1><p>通过向类的单件类中加入模块来定义类方法，是对象扩展的一个特例</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    <span class="string">'a method'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; C</span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.a_method <span class="comment"># =&gt; 'a method'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="类实例变量-Class-Instance-Variable"><a href="#类实例变量-Class-Instance-Variable" class="headerlink" title="类实例变量 Class Instance Variable"></a>类实例变量 Class Instance Variable</h1><p>在一个 Class 对象的实例变量中存储类级别的状态</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  @my_class_instance_variable = <span class="string">'some value'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">class_attribute</span></span></span><br><span class="line">    @my_class_instance_variable</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.class_attribute <span class="comment"># =&gt; 'some value'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="类宏-Class-Macro"><a href="#类宏-Class-Macro" class="headerlink" title="类宏 Class Macro"></a>类宏 Class Macro</h1><p>在类定义中使用方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; C</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span><span class="params">(arg)</span></span></span><br><span class="line">    <span class="string">"a_method(<span class="subst">#{arg}</span> called)"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  a_method <span class="symbol">:x</span> <span class="comment"># =&gt; "a_method(x) called"</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="洁净室-Clean-Room"><a href="#洁净室-Clean-Room" class="headerlink" title="洁净室 Clean Room"></a>洁净室 Clean Room</h1><p>使用一个对象作为执行一个代码块的环境</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CleanRoom</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_userful_method</span> <span class="title">x</span></span></span><br><span class="line">    x * <span class="number">2</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">CleanRoom.new.instance_eval { a_userful_method(<span class="number">3</span>) } <span class="comment"># =&gt; 6</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="代码处理器-Code-Processor"><a href="#代码处理器-Code-Processor" class="headerlink" title="代码处理器 Code Processor"></a>代码处理器 Code Processor</h1><p>处理从外部活的的代码字符串</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">File.readlines(<span class="string">'a_file_containing_lines_of_ruby.txt'</span>).each <span class="keyword">do</span> <span class="params">|line|</span></span><br><span class="line">  puts <span class="string">"<span class="subst">#{line.chomp}</span> ==&gt; <span class="subst">#{eval(line)}</span>"</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; 1 + 1 ==&gt; 2</span></span><br><span class="line"><span class="comment"># =&gt; Math.log10(100) ==&gt; 2.0</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="上下文探针-Context-Probe"><a href="#上下文探针-Context-Probe" class="headerlink" title="上下文探针 Context Probe"></a>上下文探针 Context Probe</h1><p>执行一个代码块来获取一个对象上下文中的信息</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    @x = <span class="string">'a private instance variable'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">obj.instance_eval { @x } <span class="comment"># =&gt; 'a private instance variable'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="延迟执行-Deferred-Evaluation"><a href="#延迟执行-Deferred-Evaluation" class="headerlink" title="延迟执行 Deferred Evaluation"></a>延迟执行 Deferred Evaluation</h1><p>在 proc 或 lambda 中存储一段代码及其上下文，用于以后执行</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">store</span><span class="params">(&amp;block)</span></span></span><br><span class="line">    @my_code_capsule = block</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(*args)</span></span></span><br><span class="line">    @my_code_capsule.call(*args)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">obj.store { $X = <span class="number">1</span> }</span><br><span class="line">$X = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">obj.execute</span><br><span class="line">$X <span class="comment"># =&gt; 1</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="动态派发-Dynamic-Dispatch"><a href="#动态派发-Dynamic-Dispatch" class="headerlink" title="动态派发 Dynamic Dispatch"></a>动态派发 Dynamic Dispatch</h1><p>在运行是决定调用哪个方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">method_to_call = <span class="symbol">:reverse</span></span><br><span class="line">obj = <span class="string">'abc'</span></span><br><span class="line">obj.send(method_to_call) <span class="comment"># =&gt; 'reverse'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="动态方法-Dynamic-Method"><a href="#动态方法-Dynamic-Method" class="headerlink" title="动态方法 Dynamic Method"></a>动态方法 Dynamic Method</h1><p>在运行是决定怎样定义一个方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">C.class_eval <span class="keyword">do</span></span><br><span class="line">  define_method <span class="symbol">:a_method</span> <span class="keyword">do</span></span><br><span class="line">    <span class="string">'a dynamic method'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">c.a_method <span class="comment"># =&gt; 'a dynamic method'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="动态代理-Dynamic-Proxy"><a href="#动态代理-Dynamic-Proxy" class="headerlink" title="动态代理 Dynamic Proxy"></a>动态代理 Dynamic Proxy</h1><p>把不能对应某个方法名的消息转发给另外一个对象</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDynamicProxy</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span><span class="params">(target)</span></span></span><br><span class="line">    @target = target</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(name, *args, &amp;block)</span></span></span><br><span class="line">    <span class="string">"result: <span class="subst">#{@target.send(name, *args, &amp;block)}</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = MyDynamicProxy.new(<span class="string">'a string'</span>)</span><br><span class="line">obj.reverse <span class="comment"># =&gt; 'result: gnirts a'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="扁平作用域-Flat-Scope"><a href="#扁平作用域-Flat-Scope" class="headerlink" title="扁平作用域 Flat Scope"></a>扁平作用域 Flat Scope</h1><p>使用闭包在两个作用域之间共享变量</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">an_attribute</span></span></span><br><span class="line">    @attr</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">a_variable = <span class="number">100</span></span><br><span class="line">obj.instance_eval <span class="keyword">do</span></span><br><span class="line">  @attr = a_variable</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj.an_attribute <span class="comment"># =&gt; 100</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="幽灵方法-Ghost-Method"><a href="#幽灵方法-Ghost-Method" class="headerlink" title="幽灵方法 Ghost Method"></a>幽灵方法 Ghost Method</h1><p>响应一个没有关联方法的消息</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">method_missing</span><span class="params">(name, *args)</span></span></span><br><span class="line">    name.to_s.reverse</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">obj.my_ghost_method <span class="comment"># =&gt; 'dohtem_tsohg_ym'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="钩子方法-Hook-Method"><a href="#钩子方法-Hook-Method" class="headerlink" title="钩子方法 Hook Method"></a>钩子方法 Hook Method</h1><p>复写一个方法来截获对象模型事件</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">$INHERITORS = []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">inherited</span><span class="params">(subclass)</span></span></span><br><span class="line">    $INHERITORS &lt;&lt; subclass</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> &lt; C</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> &lt; D</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">F</span> &lt; E</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">$INHERITORS <span class="comment"># =&gt; [D, E ,F]</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="内核方法-Kernel-Method"><a href="#内核方法-Kernel-Method" class="headerlink" title="内核方法 Kernel Method"></a>内核方法 Kernel Method</h1><p>在 Kernel 模块中定义一个方法，使得所有对象都可使用</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Kernel</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    <span class="string">'a kernel method'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a_method <span class="comment"># =&gt; 'a kernel method'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="惰性实例变量-Lazy-Instance-Variable"><a href="#惰性实例变量-Lazy-Instance-Variable" class="headerlink" title="惰性实例变量 Lazy Instance Variable"></a>惰性实例变量 Lazy Instance Variable</h1><p>等第一次访问一个实例变量时才对它进行初始化</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">attribute</span></span></span><br><span class="line">    @attribute = @attribute <span class="params">||</span> <span class="string">'some value'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">obj.attribute <span class="comment"># =&gt; 'some value'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="拟态方法-Mimic-Method"><a href="#拟态方法-Mimic-Method" class="headerlink" title="拟态方法 Mimic Method"></a>拟态方法 Mimic Method</h1><p>把一个方法伪装成另外一种语言构件</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BaseClass</span> <span class="title">name</span></span></span><br><span class="line">  name == <span class="string">'string'</span> ? String : Object</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &lt; BaseClass '<span class="title">string</span>' <span class="comment"># 一个看起像类的方法</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:an_attribute</span> <span class="comment"># 一个看起像关键字的方法</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj = C.new</span><br><span class="line">obj.an_attribute = <span class="number">1</span> <span class="comment"># 一个看起像属性的方法</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="猴子打补丁-Monkeypatch"><a href="#猴子打补丁-Monkeypatch" class="headerlink" title="猴子打补丁 Monkeypatch"></a>猴子打补丁 Monkeypatch</h1><p>修改已有类的特性</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'cba'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span></span><br><span class="line">    <span class="string">'override'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'override'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="命名空间-Namespace"><a href="#命名空间-Namespace" class="headerlink" title="命名空间 Namespace"></a>命名空间 Namespace</h1><p>在一个模块中定义常量，以防止命名冲突</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyNamespace</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_s</span></span></span><br><span class="line">      <span class="string">'to_a method in array of the my namespace'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">Array.new.to_s <span class="comment"># =&gt; []</span></span><br><span class="line">MyNamespace::Array.new.to_s <span class="comment"># =&gt; 'to_a method in array of the my namespace'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="空指针保护-Nil-Guard"><a href="#空指针保护-Nil-Guard" class="headerlink" title="空指针保护 Nil Guard"></a>空指针保护 Nil Guard</h1><p>用’||’操作符覆写一个空引用</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">x = <span class="literal">nil</span></span><br><span class="line">y = x <span class="params">||</span> <span class="string">'a value'</span> <span class="comment"># =&gt; 'a value'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="对象扩展-Object-Extension"><a href="#对象扩展-Object-Extension" class="headerlink" title="对象扩展 Object Extension"></a>对象扩展 Object Extension</h1><p>通过一个对象的单件类混入模块来定义单件方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">obj = Object.new</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    <span class="string">'a singleton method in M'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; obj</span></span><br><span class="line">  <span class="keyword">include</span> M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj.a_method <span class="comment"># =&gt; 'a singleton method'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="打开类-Open-Class"><a href="#打开类-Open-Class" class="headerlink" title="打开类 Open Class"></a>打开类 Open Class</h1><p>修改已有的类</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">a_method</span></span></span><br><span class="line">    <span class="string">'a method'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.a_method <span class="comment"># =&gt; 'a method'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="下包含包装器-Prepended-Wrapper"><a href="#下包含包装器-Prepended-Wrapper" class="headerlink" title="下包含包装器 Prepended Wrapper"></a>下包含包装器 Prepended Wrapper</h1><p>调用一个用 prepend 方式覆写的方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">M</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span></span><br><span class="line">    <span class="string">"x<span class="subst">#{<span class="keyword">super</span>}</span>x"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">String.class_eval <span class="keyword">do</span></span><br><span class="line">  prepend M</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'xcbax'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="细化-Refinement"><a href="#细化-Refinement" class="headerlink" title="细化 Refinement"></a>细化 Refinement</h1><p>为类打补丁，作用范围仅到文件结束，或仅限于包含模块的作用域中</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MyRefinement</span></span></span><br><span class="line">  refine String <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span></span><br><span class="line">      <span class="string">'refinement reverse'</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'cba'</span></span><br><span class="line">using MyRefinement</span><br><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'refine reverse'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="细化封装器-Refinement-Wrapper"><a href="#细化封装器-Refinement-Wrapper" class="headerlink" title="细化封装器 Refinement Wrapper"></a>细化封装器 Refinement Wrapper</h1><p>在细化中调用非细化的方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">StringRefinement</span></span></span><br><span class="line">  refine String <span class="keyword">do</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span></span></span><br><span class="line">      <span class="string">"x<span class="subst">#{<span class="keyword">super</span>}</span>x"</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">using StringRefinement</span><br><span class="line"><span class="string">'abc'</span>.reverse <span class="comment"># =&gt; 'xcbax'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="沙盒-Sandbox"><a href="#沙盒-Sandbox" class="headerlink" title="沙盒 Sandbox"></a>沙盒 Sandbox</h1><p>在一个安全的环境中执行未授权的代码</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sandbox</span> <span class="title">&amp;</span><span class="title">code</span></span></span><br><span class="line">  proc <span class="keyword">do</span></span><br><span class="line">    $SAFE = <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">  <span class="keyword">end</span>.call</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  sandbox { File.delete <span class="string">'a_file'</span> }</span><br><span class="line"><span class="keyword">rescue</span> Exception =&gt; ex</span><br><span class="line">  ex <span class="comment"># =&gt;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="作用域门-Scope-Gate"><a href="#作用域门-Scope-Gate" class="headerlink" title="作用域门 Scope Gate"></a>作用域门 Scope Gate</h1><p>用 class, module 或 def 关键字来隔离作用域</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defined</span>? a <span class="comment"># =&gt; 'local-variable'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">MModule</span></span></span><br><span class="line">  b = <span class="number">1</span></span><br><span class="line">  <span class="keyword">defined</span>? a <span class="comment"># =&gt; nil</span></span><br><span class="line">  <span class="keyword">defined</span>? b <span class="comment"># =&gt; 'local-variable'</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">defined</span>? a <span class="comment"># =&gt; 'local-variable'</span></span><br><span class="line"><span class="keyword">defined</span>? b <span class="comment"># =&gt; nil</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="Self-Yield"><a href="#Self-Yield" class="headerlink" title="Self Yield"></a>Self Yield</h1><p>把 self 传给当前代码块</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line">  <span class="keyword">attr_accessor</span> <span class="symbol">:name</span>, <span class="symbol">:surname</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">joe = Person.new <span class="keyword">do</span> <span class="params">|person|</span></span><br><span class="line">  person.name = <span class="string">'Joe'</span></span><br><span class="line">  person.surname = <span class="string">'Smith'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="共享作用域-Shared-Scope"><a href="#共享作用域-Shared-Scope" class="headerlink" title="共享作用域 Shared Scope"></a>共享作用域 Shared Scope</h1><p>在同一个扁平作用域的多个上下文中共享变量</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">lambda <span class="keyword">do</span></span><br><span class="line">  shared = <span class="number">10</span></span><br><span class="line">  <span class="keyword">self</span>.class_eval <span class="keyword">do</span></span><br><span class="line">    defined_method <span class="symbol">:counter</span> <span class="keyword">do</span></span><br><span class="line">      shared</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    defined_method <span class="symbol">:down</span> <span class="keyword">do</span></span><br><span class="line">      shared -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>.call</span><br><span class="line"></span><br><span class="line">counter <span class="comment"># =&gt; 10</span></span><br><span class="line"><span class="number">3</span>.times { down }</span><br><span class="line">counter <span class="comment"># =&gt; 7</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="单件方法-Singleton-Method"><a href="#单件方法-Singleton-Method" class="headerlink" title="单件方法 Singleton Method"></a>单件方法 Singleton Method</h1><p>在一个对象上定义一个方法</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">obj = <span class="string">'abc'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> &lt;&lt; obj</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">obj_singleton_method</span></span></span><br><span class="line">    <span class="string">'x'</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">obj.obj_singleton_method <span class="comment"># =&gt; 'x'</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="代码字符串-String-of-Code"><a href="#代码字符串-String-of-Code" class="headerlink" title="代码字符串 String of Code"></a>代码字符串 String of Code</h1><p>执行一段表示 ruby 代码的字符串</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">string_of_code = <span class="string">'1 + 1'</span></span><br><span class="line">eval(string_of_code) <span class="comment"># =&gt; 2</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="符号到Proc-Symbol-To-Proc"><a href="#符号到Proc-Symbol-To-Proc" class="headerlink" title="符号到Proc Symbol To Proc"></a>符号到 Proc Symbol To Proc</h1><p>把一个调用单个方的块转换为一个符号</p>
<figure class="highlight ruby"><table><tbody><tr><td class="code"><pre><span class="line">(<span class="number">1</span>..<span class="number">6</span>).map(&amp;<span class="symbol">:even?</span>) <span class="comment"># =&gt; [false, true, false, true, false, true]</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Ruby</category>
      </categories>
      <tags>
        <tag>Ruby</tag>
        <tag>元编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Nginx 部署静态网站</title>
    <url>/2018/09/17/%E4%BD%BF%E7%94%A8Nginx%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Nginx（发音同 engine x）是一个异步框架的 Web 服务器，也可以用作反向代理，负载平衡器 和 HTTP 缓存 </p>
</blockquote>
<h1 id="配置静态网站"><a href="#配置静态网站" class="headerlink" title="配置静态网站"></a>配置静态网站</h1><figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attribute">server_name</span> example.com; <span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / {</span><br><span class="line">        <span class="attribute">root</span> /var/www/project_dir; <span class="comment"># 静态项目路径</span></span><br><span class="line">        <span class="attribute">index</span> index.html; <span class="comment"># 网站初始页</span></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /index.html; <span class="comment"># 静态页面重定向服务器错误页面</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>
<p>将以上配置存到一个文件中，然后编辑 <code>nginx.conf</code>（使用 <code>nginx -t</code> 可以看到具体路径），用 <code>include 配置文件的路径;</code> 引入到配置中，退出编辑器，使用 <code>nginx -t</code> 来测试配置是否有误，有问题的改好后再进行下一步，使用 <code>nginx -s reload</code> 重新加载 Nginx 配置</p>
<hr>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>部署，静态</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 acme.sh 的 DNS API 配置生成通配域名证书</title>
    <url>/2020/07/11/%E4%BD%BF%E7%94%A8acme.sh%E7%9A%84DNS%20API%E9%85%8D%E7%BD%AE%E7%94%9F%E6%88%90%E9%80%9A%E9%85%8D%E5%9F%9F%E5%90%8D%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><ul>
<li><a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">acme.sh DNS API 说明</a></li>
</ul>
<h2 id="DNS-API-配置"><a href="#DNS-API-配置" class="headerlink" title="DNS API 配置"></a>DNS API 配置</h2><p>我用的使用<a href="https://www.aliyun.com/minisite/goods?userCode=cma2zz5m" target="_blank" rel="noopener">阿里云</a>域名服务，其他可以查看<a href="https://github.com/acmesh-official/acme.sh/wiki/dnsapi" target="_blank" rel="noopener">使用说明</a></p>
<p>首先，需要登录到 Aliyun 帐户以<a href="https://ak-console.aliyun.com/#/accesskey" target="_blank" rel="noopener">获取 API 密钥</a>。</p>
<a id="more"></a>
<p>然后将以下配置写入到 <code>~/.bashrc</code> 文件中，然后执行 <code>source ~/.bashrc</code></p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> Ali_Key=<span class="string">"获取到的阿里云DNS API Key"</span></span><br><span class="line"><span class="built_in">export</span> Ali_Secret=<span class="string">"获取到的阿里云DNS API Secret"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装-acme-sh"><a href="#安装-acme-sh" class="headerlink" title="安装 acme.sh"></a>安装 acme.sh</h2><p>已经安装好的请跳过</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl https://get.acme.sh | sh</span><br></pre></td></tr></tbody></table></figure>
<h2 id="执行颁发证书命令"><a href="#执行颁发证书命令" class="headerlink" title="执行颁发证书命令"></a>执行颁发证书命令</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">acme.sh --issue --force -d example.com -d *.example.com --dns dns_ali</span><br></pre></td></tr></tbody></table></figure>
<h2 id="将证书安装到指定位置"><a href="#将证书安装到指定位置" class="headerlink" title="将证书安装到指定位置"></a>将证书安装到指定位置</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">acme.sh --installcert -d example.com --key-file example.com.key的路径 --fullchain-file fullchain.cer的路径 --reloadcmd <span class="string">"systemctl force-reload nginx"</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="Nginx-配置"><a href="#Nginx-配置" class="headerlink" title="Nginx 配置"></a>Nginx 配置</h2><p>然后参考<a href="/2018/10/06/%E5%85%8D%E8%B4%B9%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0HTTPS%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/#%E4%BF%AE%E6%94%B9-Nginx-%E9%85%8D%E7%BD%AE">修改 - Nginx - 配置</a></p>
<p>现在想要获得 A+ 评级，需要设置 nginx 中的 <code>ssl_protocols</code> 只提供 TLSv1.2 或者更高的协议，禁用不安全或不在受支持的协议，我将原先的 <code>ssl_protocols</code> 更改为：</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attribute">ssl_protocols</span> TLSv1.<span class="number">2</span> TLSv1.<span class="number">3</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><a href="https://myssl.com/" target="_blank" rel="noopener">HTTPS 评级 https://myssl.com/</a></p>
<hr>
]]></content>
      <tags>
        <tag>配置</tag>
        <tag>Nginx</tag>
        <tag>acme.sh</tag>
        <tag>DNS</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>免费给自己的网站添加 HTTPS 安全加密</title>
    <url>/2018/10/06/%E5%85%8D%E8%B4%B9%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BD%91%E7%AB%99%E6%B7%BB%E5%8A%A0HTTPS%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h1><ul>
<li><a href="https://ruby-china.org/topics/31983" target="_blank" rel="noopener">使用 acme.sh 给 Nginx 安装 Let’s Encrypt 提供的免费 SSL 证书</a></li>
<li><a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E" target="_blank" rel="noopener">acme.sh 说明</a></li>
<li><a href="https://www.textarea.com/zhicheng/fenxiang-yige-https-a-di-nginx-peizhi-320/" target="_blank" rel="noopener">分享一个 HTTPS A+ 的 nginx 配置</a></li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为 HTTP over TLS，HTTP over SSL 或 HTTP Secure）是一种透过计算器网上进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在 1994 年首次提出，随后扩展到互联网上。</p>
<a id="more"></a>
<h1 id="安装-acme-sh"><a href="#安装-acme-sh" class="headerlink" title="安装 acme.sh"></a>安装 acme.sh</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl  https://get.acme.sh | sh</span><br><span class="line"><span class="comment"># 重新载入</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></tbody></table></figure>
<p>安装过程不会污染已有的系统任何功能和文件，所有的修改都限制在安装目录中: <code>~/.acme.sh/</code></p>
<h1 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h1><p><code>acme.sh</code> 实现了 <code>acme</code> 协议支持的所有验证协议。 一般有两种方式验证：<code>http</code> 和 <code>dns</code> 验证。我这里使用的是 <code>http</code> 方式，<code>http</code> 方式需要在你的网站根目录下放置一个文件，这个目录需要读写权限，来验证你的域名所有权，完成验证。其他方式可以参考 <a href="https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E#2-%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6" target="_blank" rel="noopener">acme.sh 生成证书</a>。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">acme.sh --issue -d mydomain.com -w /home/user/www/mydomain.com/</span><br></pre></td></tr></tbody></table></figure>
<h1 id="copy-安装证书"><a href="#copy-安装证书" class="headerlink" title="copy / 安装证书"></a>copy / 安装证书</h1><p>注意，默认生成的证书都放在安装目录下：<code>~/.acme.sh/</code>，请不要直接使用此目录下的文件，例如： 不要直接让 <code>nginx</code>/<code>apache</code> 的配置文件使用这下面的文件。这里面的文件都是内部使用，而且目录结构可能会变化。</p>
<p>正确的使用方法是使用 <code>--installcert</code> 命令，并指定目标位置，然后证书文件会被 copy 到相应的位置。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># key-file 服务器端的</span></span><br><span class="line">acme.sh --installcert -d mydomain.com \</span><br><span class="line">        --key-file /home/user/.nginx/ssl/mydomain.com.key \</span><br><span class="line">        --fullchain-file /home/user/.nginx/ssl/fullchain.cer \</span><br><span class="line">        --reloadcmd <span class="string">"sudo service nginx force-reload"</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里用的是 <code>service nginx force-reload</code>，不是 <code>service nginx reload</code>，据测试，<code>reload</code> 并不会重新加载证书，所以用的 <code>force-reload</code></p>
<p><code>--installcert</code> 命令可以携带很多参数，来指定目标文件。并且可以指定 <code>reloadcmd</code>，当证书更新以后，<code>reloadcmd</code> 会被自动调用，让服务器生效，详细参数请参考: <a href="https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc" target="_blank" rel="noopener">https://github.com/Neilpang/acme.sh#3-install-the-issued-cert-to-apachenginx-etc</a></p>
<p><code>Nginx</code> 的配置 <code>ssl_certificate</code> 使用 <code>/home/user/.nginx/ssl/fullchain.cer</code>，而非 <code>/home/user/.nginx/ssl/mydomain.com.cer</code>，否则 <a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">SSL Labs</a> 的测试会报 <code>Chain issues Incomplete</code> 错误</p>
<h1 id="修改-visudo"><a href="#修改-visudo" class="headerlink" title="修改 visudo"></a>修改 visudo</h1><p>修改一下 <code>sudoer</code> 文件，让 <code>sudo service nginx force-reload</code> 不需要输入密码</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></tbody></table></figure>
<p>文件内添加以下内容，<code>user</code> 是 <code>acme.sh</code> 安装所用的账号<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">user ALL=(ALL) NOPASSWD: /usr/sbin/service nginx force-reload</span><br></pre></td></tr></tbody></table></figure><p></p>
<h2 id="nano编辑器的简单使用"><a href="#nano编辑器的简单使用" class="headerlink" title="nano编辑器的简单使用"></a>nano 编辑器的简单使用</h2><ul>
<li><p>移动光标<br>用 <code>Ctrl+b</code> 移动到上一字符，<code>Ctrl+f</code> 移动到下一字符<br>用 <code>Ctrl+p</code> 移动到上一行，<code>Ctrl+n</code> 移动到下一行<br>用 <code>Ctrl+y</code> 移动到上一页，<code>Ctrl+v</code> 移动到下一页</p>
</li>
<li><p>保存<br>使用 <code>Ctrl+o</code> 来保存所做的修改，回车即可</p>
</li>
<li><p>退出<br>按 <code>Ctrl+x</code></p>
</li>
<li><p>其他<br>其中 <code>^</code> 表示 <code>Ctrl</code> 键，<code>M</code> 表示 <code>Alt</code> 键</p>
</li>
</ul>
<h2 id="使用其他编辑器"><a href="#使用其他编辑器" class="headerlink" title="使用其他编辑器"></a>使用其他编辑器</h2><p>如果觉得 nano 不好用，可以设置使用其他编辑器，输入以下后，按照提示选择即可</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo update-alternatives --config editor</span><br></pre></td></tr></tbody></table></figure>
<h1 id="生成-dhparam-pem-文件"><a href="#生成-dhparam-pem-文件" class="headerlink" title="生成 dhparam.pem 文件"></a>生成 dhparam.pem 文件</h1><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">openssl dhparam -out /home/user/.nginx/ssl/dhparam.pem 2048</span><br></pre></td></tr></tbody></table></figure>
<h1 id="修改-Nginx-配置"><a href="#修改-Nginx-配置" class="headerlink" title="修改 Nginx 配置"></a>修改 Nginx 配置</h1><figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span> mydomain.com;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 证书文件</span></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /home/user/.nginx/ssl/fullchain.cer;</span><br><span class="line">    <span class="comment"># 证书私钥</span></span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> /home/user/.nginx/ssl/mydomain.com.key;</span><br><span class="line">    <span class="comment"># 为DHE密码指定具有DH参数的文件</span></span><br><span class="line">    <span class="attribute">ssl_dhparam</span> /home/user/.nginx/ssl/dhparam.pem;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启缓存，有利于减少SSL握手开销</span></span><br><span class="line">    <span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10m</span>;</span><br><span class="line">    <span class="comment"># SSL会话过期时间，有利于减少服务器开销</span></span><br><span class="line">    <span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br><span class="line">    <span class="comment"># 指定可用的SSL协议</span></span><br><span class="line">    <span class="attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="comment"># 屏蔽不安全的加密方式</span></span><br><span class="line">    <span class="attribute">ssl_ciphers</span> <span class="string">"ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA"</span>;</span><br><span class="line">    <span class="comment"># 指定在使用SSLv3和TLS协议时，服务器密码应优先于客户端密码</span></span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="comment"># 开启HSTS，强制全站加密，如果你的网站要引用不加密的资源，或者考虑将来取消加密，就不要开这个</span></span><br><span class="line">    <span class="attribute">add_header</span> Strict-Transport-Security <span class="string">"max-age=63072000; includeSubdomains; preload"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ... 其他配置</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>配置好后，执行<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 测试配置是否有问题</span></span><br><span class="line">sudo service nginx configtest</span><br><span class="line"><span class="comment"># 重启nginx服务</span></span><br><span class="line">sudo service nginx restart</span><br></pre></td></tr></tbody></table></figure><p></p>
<h1 id="测试SSL服务"><a href="#测试SSL服务" class="headerlink" title="测试SSL服务"></a>测试 SSL 服务</h1><p>按照以上步骤完整配好后，应该是 A+<br>测试地址：<a href="https://www.ssllabs.com/ssltest/" target="_blank" rel="noopener">https://www.ssllabs.com/ssltest/</a></p>
<h1 id="后续维护"><a href="#后续维护" class="headerlink" title="后续维护"></a>后续维护</h1><p>目前由于 <code>acme</code> 协议和 <code>letsencrypt CA</code> 都在频繁的更新，因此 <code>acme.sh</code> 也经常更新以保持同步.</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">acme.sh --upgrade</span><br><span class="line"><span class="comment"># 开启自动更新</span></span><br><span class="line">acme.sh --upgrade --auto-upgrade</span><br><span class="line"><span class="comment"># 关闭自动更新</span></span><br><span class="line">acme.sh --upgrade --auto-upgrade 0</span><br></pre></td></tr></tbody></table></figure>
<p>目前证书在 60 天以后会自动更新，需要定期重新申请，这部分 <code>acme.sh</code> 已经帮你做了，在安装的时候往 <code>crontab</code> 增加了一行每天执行的命令，执行 <code>crontab -l</code>，会看到以下信息</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">49 0 * * * <span class="string">"/home/user/.acme.sh"</span>/acme.sh --cron --home <span class="string">"/home/user/.acme.sh"</span> &gt; /dev/null</span><br></pre></td></tr></tbody></table></figure>
<p>你可以尝试执行一下，看看是否正确运行<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"/home/user/.acme.sh"</span>/acme.sh --cron --home <span class="string">"/home/user/.acme.sh"</span></span><br></pre></td></tr></tbody></table></figure><p></p>
<p>最后走一下 <code>acme.sh --cron</code> 的流程看看能否正确执行<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">acme.sh --cron -f</span><br></pre></td></tr></tbody></table></figure><p></p>
<hr>
]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
        <tag>Nginx</tag>
        <tag>acme.sh</tag>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>向 Gogs 仓库推送代码后，自动更新远程仓库的代码</title>
    <url>/2018/09/20/%E5%90%91Gogs%E4%BB%93%E5%BA%93%E6%8E%A8%E9%80%81%E4%BB%A3%E7%A0%81%E5%90%8E%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Gogs 服务同博客静态服务在同一服务器，我想每次 push 后，Gogs 接受成功后会自动更新远程服务器的资源</p>
</blockquote>
<a id="more"></a>
<p>用 Hexo 框架写完博客后，使用 <code>hexo d -g</code> 会将生成好的静态资源推送到自己的远程仓库，远程服务器每次都要登上去手动 <code>git pull</code>，而写个 <code>crontab</code> 有又觉得不怎么好，然后就找到了 <a href="https://git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90" target="_blank" rel="noopener">Git 服务端钩子</a><code>post-receive</code> 此挂钩在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户</p>
<p>这个钩子在 Gogs 的 <code>gogs-repositories</code> 目录下，每一个仓库目录下都有 <code>hooks/post-receive</code> 这个钩子，将以下改好后添加到文件内即可</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> GIT_DIR</span><br><span class="line">NowPath=`<span class="built_in">pwd</span>`</span><br><span class="line">DeployPath=<span class="string">"/var/www/blog"</span> <span class="comment"># 要将这里的路径修改为远程服务器上存放博客静态资源的目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$DeployPath</span></span><br><span class="line">git pull origin master</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$NowPath</span></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></tbody></table></figure>
<hr>
]]></content>
      <categories>
        <category>Gogs</category>
      </categories>
      <tags>
        <tag>Gogs</tag>
        <tag>自动部署</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Ubuntu 上部署 Gogs</title>
    <url>/2018/09/22/%E5%9C%A8Ubuntu%E4%B8%8A%E9%83%A8%E7%BD%B2Gogs/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>Gogs 是一款极易搭建的自助 Git 服务。</p>
</blockquote>
<h1 id="为什么选择Gogs"><a href="#为什么选择Gogs" class="headerlink" title="为什么选择Gogs"></a>为什么选择 Gogs</h1><p>我之前也部署过 Gitlab，但是太吃资源了，Gogs 相比就很轻量，正好合适搭建私人 Git 服务器。</p>
<a id="more"></a>
<h1 id="安装Nginx和数据库"><a href="#安装Nginx和数据库" class="headerlink" title="安装Nginx和数据库"></a>安装 Nginx 和数据库</h1><p>要部署 Gogs，需要安装 Nginx 和数据库</p>
<p>安装 Nginx</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></tbody></table></figure>
<h2 id="安装和初始化数据库"><a href="#安装和初始化数据库" class="headerlink" title="安装和初始化数据库"></a>安装和初始化数据库</h2><p>Gogs 支持 MySQL，PostgreSQL，SQLite3，MSSQL 和 TiDB，这里我选择 PostgreSQL</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install postgresql</span><br></pre></td></tr></tbody></table></figure>
<p>命令执行完毕后，配置数据库</p>
<h3 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h3><p>安装完毕后需要更改 postgres 用户的密码，否则就没法使用这个数据库服务器。以 postgres 这个系统用户的身份运行 psql 命令</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sudo -u postgres psql</span><br></pre></td></tr></tbody></table></figure>
<p>进入 psql 命令接口</p>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> postgres <span class="keyword">WITH</span> <span class="keyword">PASSWORD</span> <span class="string">'这里写postgres用户的新密码'</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>执行完毕后，<code>\q</code> 退出</p>
<h3 id="创建PostgreSQL的新用户和数据库"><a href="#创建PostgreSQL的新用户和数据库" class="headerlink" title="创建PostgreSQL的新用户和数据库"></a>创建 PostgreSQL 的新用户和数据库</h3><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># -D 没有创建数据库的权限</span></span><br><span class="line"><span class="comment"># -A 没有新建用户的权限</span></span><br><span class="line"><span class="comment"># -P 为新用户设置密码</span></span><br><span class="line">sudo -u postgres createuser -D -A -P gogs <span class="comment"># 创建用户时会提示你输入密码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个数据库gogs-db，以 gogs 作为它的所有者</span></span><br><span class="line">sudo -u postgres createdb -O gogs gogs-db</span><br></pre></td></tr></tbody></table></figure>
<h1 id="安装Gogs"><a href="#安装Gogs" class="headerlink" title="安装Gogs"></a>安装 Gogs</h1><h2 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h2><p>为什么创建一个新的用户呢？之前我也一直在纠结。后来，发生了密钥冲突，这个就是因为管理员密钥月 Gogs 运行应用的用户密钥一样所导致的，如果 Gogs 运行应用的用户不是管理员也就不会有这个情况了</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">useradd -m git</span><br><span class="line"><span class="comment"># 切换到git用户</span></span><br><span class="line">sudo su git</span><br><span class="line"><span class="comment"># 切换到git用户的HOME目录</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></tbody></table></figure>
<p>下面操作都是在 git 用户下操作</p>
<h2 id="下载Gogs程序"><a href="#下载Gogs程序" class="headerlink" title="下载Gogs程序"></a>下载 Gogs 程序</h2><p>我使用的是 <a href="https://gogs.io/docs/installation/install_from_binary#%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%87%E7%BA%A7%EF%BC%9F" target="_blank" rel="noopener">Gogs 二进制安装包</a>，下载的是 Linux，64 位，TAR.GZ，可以用 <code>curl</code> 或者 <code>wget</code> 下载文件</p>
<p>示例<br></p><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 使用curl</span></span><br><span class="line">curl -O https://dl.gogs.io/0.11.66/gogs_0.11.66_linux_amd64.tar.gz</span><br><span class="line"><span class="comment"># 使用 wget</span></span><br><span class="line">wget https://dl.gogs.io/0.11.66/gogs_0.11.66_linux_amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure><p></p>
<p>解压</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">tar -zxvf gogs_0.11.66_linux_amd64.tar.gz</span><br></pre></td></tr></tbody></table></figure>
<h2 id="启动Gogs服务"><a href="#启动Gogs服务" class="headerlink" title="启动Gogs服务"></a>启动 Gogs 服务</h2><figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> gogs</span><br><span class="line">./gogs web</span><br></pre></td></tr></tbody></table></figure>
<p>然后再浏览器输入 <code>IP:3000</code>，端口号默认是 3000，这个时候进入应该进入的是 <code>/install</code>，具体就是一些 Gogs 程序的基本设置，填完提交后，进入命令行按 <code>ctl+c</code> 结束程序，就可以进行下一步了</p>
<h1 id="Gogs守护进程"><a href="#Gogs守护进程" class="headerlink" title="Gogs守护进程"></a>Gogs 守护进程</h1><p>这部分主要修改 Gogs 项目中的 <code>scripts</code> 里的文件，以下文件请根据实际情况做修改</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vim scripts/init/debian/gogs</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          gogs</span></span><br><span class="line"><span class="comment"># Required-Start:    $syslog $network</span></span><br><span class="line"><span class="comment"># Required-Stop:     $syslog</span></span><br><span class="line"><span class="comment"># Should-Start:      mysql postgresql</span></span><br><span class="line"><span class="comment"># Should-Stop:       mysql postgresql</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:      0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: A self-hosted Git service written in Go.</span></span><br><span class="line"><span class="comment"># Description:       A self-hosted Git service written in Go.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Author: Danny Boisvert</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do NOT "set -e"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PATH should only include /usr/* if it runs after the mountnfs.sh script</span></span><br><span class="line">PATH=/sbin:/usr/sbin:/bin:/usr/bin</span><br><span class="line">DESC=<span class="string">"Gogs"</span></span><br><span class="line">NAME=gogs</span><br><span class="line">SERVICEVERBOSE=yes</span><br><span class="line">PIDFILE=/var/run/<span class="variable">$NAME</span>.pid</span><br><span class="line">SCRIPTNAME=/etc/init.d/<span class="variable">$NAME</span></span><br><span class="line">WORKINGDIR=/home/git/gogs <span class="comment"># 这是Gogs运行应用的项目路径</span></span><br><span class="line">DAEMON=<span class="variable">$WORKINGDIR</span>/<span class="variable">$NAME</span></span><br><span class="line">DAEMON_ARGS=<span class="string">"web"</span></span><br><span class="line">USER=git <span class="comment"># 这是Gogs运行应用的用户</span></span><br><span class="line"><span class="comment"># 以下不做修改</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后退出，接着修改下一个文件</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">vim scripts/systemd/gogs.service</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Gogs</span><br><span class="line">After=syslog.target</span><br><span class="line">After=network.target</span><br><span class="line"><span class="comment"># 修改这里，如果用到其他服务的话</span></span><br><span class="line"><span class="comment"># After=mariadb.service mysqld.service postgresql.service memcached.service redis.service</span></span><br><span class="line"><span class="comment"># 我这只用到了postgresql</span></span><br><span class="line">After=postgresql.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=git <span class="comment"># 这是Gogs运行应用的用户</span></span><br><span class="line">Group=git <span class="comment"># 该用户的组</span></span><br><span class="line">WorkingDirectory=/home/git/gogs <span class="comment"># 这是Gogs运行应用的项目路径</span></span><br><span class="line"><span class="comment"># /home/git/gogs/gogs这是Gogs运行应用程序的位置</span></span><br><span class="line">ExecStart=/home/git/gogs/gogs web</span><br><span class="line">Restart=always</span><br><span class="line"><span class="comment"># Environment=USER后是Gogs运行应用的用户</span></span><br><span class="line"><span class="comment"># HOME是该用户的HOME路径</span></span><br><span class="line">Environment=USER=git HOME=/home/git</span><br><span class="line"><span class="comment"># 以下不做修改</span></span><br></pre></td></tr></tbody></table></figure>
<p>修改完之后，软连接文件到相应位置</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 退出git用户，切到管理员</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">sudo ln -s /home/git/gogs/scripts/init/debian/gogs /etc/init.d/gogs</span><br><span class="line">sudo ln -s /home/git/gogs/scripts/systemd/gogs.service  /etc/systemd/system/gogs.service</span><br></pre></td></tr></tbody></table></figure>
<p>然后就可以使用 <code>service</code> 命令来管理 Gogs 的服务状态了</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 例如，启动gogs服务</span></span><br><span class="line">sudo service gogs start</span><br></pre></td></tr></tbody></table></figure>
<h1 id="Nginx反向代理Gogs服务"><a href="#Nginx反向代理Gogs服务" class="headerlink" title="Nginx反向代理Gogs服务"></a>Nginx 反向代理 Gogs 服务</h1><p>只需要在 Nginx 配置里新引入一个 <code>server</code> 就可以了</p>
<figure class="highlight nginx"><table><tbody><tr><td class="code"><pre><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>; <span class="comment"># 端口号</span></span><br><span class="line">    <span class="attribute">server_name</span> gogs.example.com; <span class="comment"># 域名</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / {</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://localhost:3000; <span class="comment"># Gogs 服务地址</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>添加完后，执行 <code>sudo nginx -t</code> 查看是否有误，然后使用 <code>sudo nginx -s reload</code> 重载 Nginx，就可以了</p>
<hr>
]]></content>
      <categories>
        <category>Gogs</category>
      </categories>
      <tags>
        <tag>Gogs</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>解决 NFS 读写文件异常</title>
    <url>/2020/07/19/%E8%A7%A3%E5%86%B3NFS%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>应用程序在读取 Linux 环境使用 NFS 挂载的文件时，发现几 Kb 的文件读取时很正常，但是读取上 Mb 的文件时特别慢。多方搜索和询问，是因为升级内核后，需要修改同时发起的 NFS 请求数量即可解决问题</p>
<a id="more"></a>
<h1 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h1><ul>
<li>阿里云 - <a href="https://help.aliyun.com/knowledge_detail/125389.html#task-1130493" target="_blank" rel="noopener">如何修改同时发起的 NFS 请求</a></li>
</ul>
<h1 id="如何修改同时发起的NFS请求数量"><a href="#如何修改同时发起的NFS请求数量" class="headerlink" title="如何修改同时发起的NFS请求数量"></a>如何修改同时发起的 NFS 请求数量</h1><p>NFS 客户端对于同时发起的 NFS 请求数量进行了控制，默认编译的内核中此参数值为 2，严重影响性能，建议修改为 128。本文介绍如何修改同时发起的 NFS 请求数量。</p>
<p>您可以通过以下两种方法修改同时发起的 NFS 请求数量。</p>
<p><strong>说明</strong> 使用方法一修改完成后，需要重启服务器 ECS，重启服务器可能影响您的业务使用。如果您不想重启服务器，可以使用方法二修改同时发起的 NFS 请求数量。</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><ol>
<li><p>安装 NFS 客户端，详情请参见<a href="https://help.aliyun.com/document_detail/90529.html#section-kvj-d02-szj" target="_blank" rel="noopener">安装 NFS 客户端</a>。</p>
</li>
<li><p>执行以下命令，将同时发起的 NFS 请求数量修改为 128。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"options sunrpc tcp_slot_table_entries=128"</span> &gt;&gt; /etc/modprobe.d/sunrpc.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"options sunrpc tcp_max_slot_table_entries=128"</span> &gt;&gt;  /etc/modprobe.d/sunrpc.conf</span><br></pre></td></tr></tbody></table></figure>
<p><strong>说明</strong> 您只需在首次安装 NFS 客户端后执行一次此操作（必须通过 root 用户操作），之后无需重复执行。</p>
</li>
<li><p>重启云服务器 ECS。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>挂载文件系统，详情请参见<a href="https://help.aliyun.com/document_detail/90529.html#section-spc-nlh-cfb" target="_blank" rel="noopener">挂载 NFS 文件系统</a>。</p>
</li>
<li><p>执行以下命令查看修改结果。</p>
<p>如果返回值为 128，则说明修改成功。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cat /proc/sys/sunrpc/tcp_slot_table_entries</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><ol>
<li><p>安装 NFS 客户端，详情请参见<a href="https://help.aliyun.com/document_detail/90529.html#section-kvj-d02-szj" target="_blank" rel="noopener">安装 NFS 客户端</a>。</p>
</li>
<li><p>执行以下命令，将同时发起的 NFS 请求数量修改为 128。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"options sunrpc tcp_slot_table_entries=128"</span> &gt;&gt; /etc/modprobe.d/sunrpc.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"options sunrpc tcp_max_slot_table_entries=128"</span> &gt;&gt;  /etc/modprobe.d/sunrpc.conf</span><br></pre></td></tr></tbody></table></figure>
<p><strong>说明</strong> 您只需在首次安装 NFS 客户端后执行一次此操作（必须通过 root 用户操作），之后无需重复执行。</p>
</li>
<li><p>挂载文件系统，详情请参见<a href="https://help.aliyun.com/document_detail/90529.html#section-spc-nlh-cfb" target="_blank" rel="noopener">挂载 NFS 文件系统</a>。</p>
</li>
<li><p>执行以下命令，再次将同时发起的 NFS 请求数量修改为 128。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">sysctl -w sunrpc.tcp_slot_table_entries=128</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>卸载文件系统，详情请参见<a href="https://help.aliyun.com/document_detail/91479.html#task-f5r-3kk-2fb" target="_blank" rel="noopener">在 Linux 系统中卸载文件系统</a>。</p>
</li>
<li><p>重新挂载文件系统，详情请参见<a href="https://help.aliyun.com/document_detail/90529.html#section-spc-nlh-cfb" target="_blank" rel="noopener">挂载 NFS 文件系统</a>。</p>
</li>
<li><p>执行以下命令查看修改结果。</p>
<p>如果返回值为 128，则说明修改成功。</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">cat /proc/sys/sunrpc/tcp_slot_table_entries</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>NFS</category>
      </categories>
      <tags>
        <tag>NFS</tag>
      </tags>
  </entry>
</search>
